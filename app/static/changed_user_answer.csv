,Unnamed: 0,problem_id,problem,assign,user_answer,scoring_criterion,correct_scoring_criterion,keyword_criterion,correct_keyword_criterion,annotator
0,0,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 개인 PC에 text로 저장된다. 세션은 접속중인 웹 서버에 Object로 저장된다. 속도는 세션보다 쿠키가 더 빠르다. 왜냐하면 세션은 DB와 통신을 해야하기 때문이다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[2, 3]",mjw8523@gmail.com
1,1,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여,서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2, 3]",mjw8523@gmail.com
2,2,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키와 세션의 가장 큰 차이점은 정보가 저장되는 위치입니다. 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2, 3]",mjw8523@gmail.com
3,3,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 보안성이 좋습니다. ,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
4,4,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있습니다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']",[0],mjw8523@gmail.com
5,5,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다. 
","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[1],"['라이프사이클', '보안', '저장위치', '속도']",[3],mjw8523@gmail.com
6,6,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크에 저장하고 세션은 서버의 메모리에 저장합니다. 저장할 때 쿠키는 text형식으로 저장하고 세션은 Object 형식으로 저장합니다. ,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
7,7,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버의 자원을 사용하지 않는다. 하지만 세션은 서버에 저장되고 서버의 메모리로 로딩이 되기 때문에 세션이 생길때마다 서버의 리소스를 차지한다. ,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
8,8,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 저장할 때 expires 속성을 정의해 무효화 시키면 삭제될 날짜를 지정할 수 있다. (따로 지정되지 않은 경우에는 브라우저 종료시 만료) 반면에 세션은 클라이언트가 로그아웃하거나, 설정한 시간동안 반응이 없을경우 무효화 되기 때문에 정확한 시점을 알 수 없다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']",[0],mjw8523@gmail.com
9,9,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 자동완성이나, 팝업 일주일간 보지 않기 등 사용자의 편의를 위하는 것이지만  지워져도 되고, 조작되거나 가로채이더라도 큰 지장이 없는 수준의 정보들을 저장하는데 사용됩니다. 그리고 사용자나 다른 누군가에게 노출되면 안되는 중요한 정보들은 세션으로 서버안에서 다뤄집니다. 쿠키로 노출시켜서는 안될 정보들이 있고, 세션을 남발하면 서버에 부담이 되어 과부하가 일어나기 때문에 웹을 설계할 때는 이 정보는 쿠키에 저장할 지 세션에 저장할 지 적절한 판단을 내릴 수 있어야 합니다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
10,10,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트 로컬에 저장되는 Key-Value쌍의 작은 데이터 파일입니다. 그리고 세션은 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술입니다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
11,11,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키와 세션의 차이점은 저장위치, 보안, Lifecycle, 속도 총 4가지 입니다. 쿠키는 로컬에, 세션은 로컬과 서버에 저장됩니다. 쿠키는 탈취와 변조가 가능하지만, 세션은 ID값만 가지고 있고 서버에도 저장이 되어있기 때문에 상대적으로 안전합니다. 쿠키는 브라우저를 종료해도 파일로 남아있지만, 세션은 브라우저 종료시 세션을 삭제합니다. 쿠키는 파일에서 읽기 때문에 상대적으로 빠르고, 세션은 요청마다 서버에서 처리를 해야하기 때문에 비교적 느립니다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1, 2, 3]","['라이프사이클', '보안', '저장위치', '속도']","[0, 1, 2, 3]",mjw8523@gmail.com
12,12,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 클라이언트, 세션 정보는 서버 측에 저장됩니다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
13,13,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,세션은 웹 서버에 저장되고 쿠키는 클라이언트(접속자 PC)에 저장된다. 세션은 Object로 저장되고 쿠키는 Text형태로 저장된다. ,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
14,14,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키의 만료시점은 쿠키 저장시 설정하기 때문에 브라우저가 종료되도, 만료시점이 지나지 않으면 자동 삭제되지 않습니다. 그러나 세션은 브라우저 종료시 삭제된다. 그리고 보안의 측면에서 세션은 서버가 관리하기 때문에 보안성이 쿠키보다 좋다. 쿠키는 클라이언트가 관리하기 때문에 해킹에 취약하다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2, 3]","['라이프사이클', '보안', '저장위치', '속도']","[0, 1, 2]",mjw8523@gmail.com
15,15,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
16,16,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다.  ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2, 3]",mjw8523@gmail.com
17,17,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 클라이언트(브라우저)에 메모리 또는 파일에 저장하고, 세션은 서버 메모리에 저장된다. 쿠키는 파일로 저장되는 경우 탈취, 변조될 위험이 있고, Request/Response에서 스나이핑 당할 위험이 있어 보안이 비교적 취약하다. 반대로 Session은 클라이언트 정보 자체가 서버에 저장되어 있으므로 비교적 안전하다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
18,18,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 지속 쿠키의 경우에 브라우저를 종료하더라도 저장되어 있을 수 있는 반면에 세션은 서버에서 만료시간 / 날짜를 정해서 지워버릴 수 있기도 하고 세션 쿠키에 세션 아이디를 정한 경우, 브라우저 종료시 세션아이디가 날아갈 수 있다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']",[0],mjw8523@gmail.com
19,19,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키에 정보가 있기 때문에 서버에 요청시 헤더를 바로 참조하면 되므로 속도에서 유리하지만, 세션은 제공받은 세션아이디(Key)를 이용해서 서버에 다시 데이터를 참조해야하므로 속도가 비교적 느릴 수 있다. ","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[1],"['라이프사이클', '보안', '저장위치', '속도']",[3],mjw8523@gmail.com
20,20,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 수학에서 사용하는 용어에서 유래한 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 뜻합니다.
","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
21,21,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"서버의 상태는 멱등성이 유지되어야 하는 경우 같은 행위를 여러 번 반복하더라도 같은 효과를 가져야 합니다.
","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
22,22,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등한 메서드는 서버의 상태를 변경시킬 수도 있고, 시키지 않을 수도 있습니다. 다만 요청한 사항은 에러가 나거나, 지연이 발생하지 않는 한 요청에 대한 서버의 상태는 항상 같습니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[0],"['동일한 요청', '상태']",[1],mjw8523@gmail.com
23,23,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 효과를 가지고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method가 멱등성을 가진다고 한다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
24,24,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,HTTP Method의 멱등성은 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 효과를 가지는 것 이다. 같은 요청을 했을 때 응답하는 상태코드가 바뀌더라도 서버의 상태가 항상 같은 상태라면 멱등성이 있다고 판단한다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
25,25,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"우리가 흔히 사용하는 HTTP Method는 GET, POST, PUT, PATCH, DELETE가 있다. HTTP 스펙에 명시된 것에 의하면 GET, PUT, DELETE는 멱등성을 가지도록, POST와 PATCH는 멱등성을 가지지 않도록 구현해야 한다. ","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[],"['동일한 요청', '상태']",[],mjw8523@gmail.com
26,26,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,HTTP 메서드의 멱등성은 여러번 요청을 보내더라도 서버의 상태가 변하지 않는 것을 말한다. 검정색 물감통에 붓을 찍으면 항상 검정 물감이 찍혀 나오는 것과 같다. HTTP 메서드의 멱등성은 단지 규약일 뿐이라서 꼭 지켜야 하는건 아니지만 규약들을 제대로 지키지 않으면 원치 않는 동작을 야기할 가능성이 크기 때문에 가능한 규약을 지켜 그에 맞는 동작을 하도록 구현하는게 좋다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
27,27,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다. 다른 말로는, 멱등성 메서드에는 통계 기록 등을 제외하면 어떠한 부수 효과(side effect)도 존재해서는 안됩니다. 올바르게 구현한 경우 GET, HEAD, PUT, DELETE 메서드는 멱등성을 가지며 POST 메서드는 그렇지 않습니다. 모든 안전한 메서드는 멱등성도 가집니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
28,28,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성은 동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고 서버의 상태도 동일하게 남는 것 입니다. 멱등성을 따질 땐 실제 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있습니다. 첫 번째 DELETE 요청이 200을 반환한다면 그 이후에는 아마 404를 반환할 것입니다. 하지만 두 번째 DELETE 요청에서 200이 또 반환된다면 그건 멱등성 규율을 위반한 예시입니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
29,29,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 특정 메서드의 요청을 여러번 하더라도 한번 요청했을 때와 결과가 같다면 멱등하다라고고 한다. PUT, DELETE, TRACE 및 GET, HEAD, OPTIONS가 멱등성을 갖는다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
30,30,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등법칙또는 멱등성은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. 정리하자면 특정 HTTP 메서드를 여러 번 요청을 했을 경우, 매번 요청 결과가 같다면 해당 메소드를 멱등성 메서드라고 한다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
31,31,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성은 어떠한 값에 대해 여러번 동일한 연산을 수행하였을 때, 호출 횟수에 구애받지 않고 동일한 결과값을 내어주는 성질이라고 이해하면 될 것 같다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
32,32,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한번 보내는 것과, 여러번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method가 멱등성을 갖는다고 이야기한다. 멱등성을 따질 때에는 서버의 상태만 바라보면 되며, HTTP 응답 Status는 신경쓰지 않아도 된다. ","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
33,33,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. GET 요청 같은 경우 여러 번 호출해도 클라이언트는 동일한 응답을 받는다. 또한 POST는 여러 번 호출할 경우 여러 열이 추가된다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
34,34,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다. 멱등성이 성립하는 메소드는 통계 기록을 제외하면 어떠한 side effect도 존재해서는 안된다. ","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
35,35,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. 멱등성을 따질 때에는 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있다. ","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
36,36,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 어떤 대상에 같은 연산을 여러번 적용해도 결과가 달라지지 않는 성질이다. 예를 들어 어떠한 수에 1을 곱하는 x = x * 1과 같은 함수는 어떠한 값에 1번을 적용하던, 1000번을 적용하던 항상 x를 반환한다. 이런 연산을 멱등성이 보장된다고 한다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
37,37,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"HTTP 메소드 또한 결국 어떤 자원을 쓰고 읽고 수정하고 지우는 CRUD의 의미를 가지기 때문에, 우리는 어떤 행위가 멱등성을 보장하고 어떤 행위가 멱등성을 보장하지 않는지 알고 있어야 어플리케이션이 예상하지 못한 방향으로 동작하는 것을 방지할 수 있다.
","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[],"['동일한 요청', '상태']",[],mjw8523@gmail.com
38,38,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,같은 연산을 여러번 반복하더라도 결과가 달라지지 않는 성질이 멱등성인데 HTTP 요청 같이 통신 회선상에서 일어나는 사건에서도 멱등성은 중요한 개념이다. 오류가 발생했을 경우 서버에서 멱등성을 보장하지 않는다면 재시도를 하지 않아야 한다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
39,39,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 멱등성(idempotence)이라 한다. Rest api의 경우 get, head, put, delete 메소드는 멱등성을 가지고 있다. 그러나 post는 상태를 변화시키기 때문에 멱등성이 없다. (Status 변화를 준다.)","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
40,40,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"같은 타입의 데이터를 나열한 선형 자료구조이며, 연속된 메모리 공간에 순차적으로 저장한다. 또한 크기가 고정되어 있고, 선언 시 배열의 크기를 정하고 이를 변경할 수 없다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[2],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],shiroed1211@gmail.com
41,41,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"고정된 크기를 갖는 같은 자료형의 원소들이 연속적인(논리적 저장 순서와 물리적 저장 순서가 일치) 형태로 구성된 자료구조. 인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다. 처음 크기를 10으로 지정한다면 5개의 데이터만 저장하더라도 실제 배열의 크기는 10이다. 고정이고 연속적인 만큼 인덱스로 random access가 가능하다. 접근, 수정 O(1)으로 빠르게 조회가 가능하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",shiroed1211@gmail.com
42,42,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 같은 타입의 데이터를 여러개 나열한 선형 자료구조로, 연속적인 메모리 공간에 순차적으로 데이터를 저장한다. 배열은 선언할 때 크기를 정하면, 그 크기로 고정이 된다. 선언된 값은 다시 배열을 선언하지 않으면 변경할 수 없다. 배열의 주소를 살펴보면, 한 칸마다 배열의 자료형의 크기를 가지고 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[2],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],shiroed1211@gmail.com
43,43,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,배열은 실제 메모리 상에도 메모리가 순차적으로 저장된다. 따라서 어느 위치에 있는지 인덱스로 손쉽게 접근할수 있는 것이다. 배열은 인덱스를 사용해서 무작위 접근(random access)가 가능하여 검색 성능이 빠르다. 순차 접근(sequential access)이 연결리스트보다 빠르다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",shiroed1211@gmail.com
44,44,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,같은 자료형을 가진 변수를 하나로 나타낸 것이다. 연속된 메모리 공간으로 이루어져있다. 정적 표현이다. 인덱스를 이용하여 표현한다. 지역성을 갖고 있다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[],shiroed1211@gmail.com
45,45,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,여러 데이터를 하나의 이름으로 그룹핑해서 관리 하기 위한 자료구조. index와 값의 쌍으로 구성 index는 값에 대한 unique한 id와 같은 역할이자 Array에서는 순서를 나타냄. 논리적 저장 순서와 물리적 저장 순서가 일치하기 때문에 index로 해당 원소에 접근할 수 있다. (O(1)) 연속된 메모리의 공간으로 이루어져 있다. 배열은 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],shiroed1211@gmail.com
46,46,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"데이터 여러개를 순차적으로 나열한 자료구조이다.
연속적인 메모리 공간에 순차적으로 나열했다.
선언한 이후에 크기는 고정이다. random access 에 매우 강하다. 시간 복잡도가 1이다.
구현이 쉽다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1]",shiroed1211@gmail.com
47,47,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 메모리상에 순서대로 데이터를 저장합니다. 배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],shiroed1211@gmail.com
48,48,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"연관된 데이터를 연속적인 형태로 구성된 구조인 자료구조. 자바스크립트 배열의 길이는 언제든 늘어나거나 줄어들 수 있고, 연속적이지 않게 저장할 수 있어 밀집성을 보장하지 않는다. 인덱스를 통해 요소에 접근할 수 있고 반드시 정수로만 접근할 수 있다. 대괄호 구문이나 속성 접근자를 사용할 경우 배열의 요소가 아니라 Array 객체에 연결된 변수를 참조한다. 원하는 원소의 index를 알고 있다면 O(1)로 원소를 찾을 수 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",shiroed1211@gmail.com
49,49,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"연속된 메모리의 공간에 순차적으로 데이터를 저장하는 선형 자료구조이다.
크기가 고정적이고 공간이 낭비되거나 재할당이 필요할 수 있다. 자바스크립트 처럼 대부분의 스크립트 언어는 배열의 크기를 동적으로 변경할 수 있다.
논리적인 저장 순서와 물리적(메모리) 저장 순서가 일치한다. 인덱스를 사용해 특정 원소에 접근이 가능하다.(Random Access ) 메모리는 배열이 선언될 때(컴파일 할 때) Stack영역에 할당한다. 시간복잡도는 O(1)이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",shiroed1211@gmail.com
50,50,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"연관된 데이터를 하나의 변수에 그룹핑해서 관리하기 위한 선형 자료구조로
배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있으며,
반복문과 결합하여 효율적으로 데이터를 처리할 수 있다.
주로 데이터의 개수가 정해져 있는 경우나 데이터의 수정이 적은 경우,
혹은 데이터의 검색이 빈번한 경우에 사용하는 선형 자료구조형이다.
배열의 특징으로는 배열안의 데이터들은 같은 자료형으로 나열되있다는 것,
그리고 데이터가 연속된 메모리 공간에 순차적으로 저장 된다는 것,
그래서 배열의 논리적 순서(인덱스)와 원소값의 물리적인 순서(메모리 주소)
두가지가 동일하다는 것 등을 꼽을 수 있다.
원소가 키와 값으로 이루어져 탐색 시간은 O(1)이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",shiroed1211@gmail.com
51,51,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"여러 데이터를 하나의 이름으로 그룹핑해서 관리하는 자료구조(하나의 변수에 여러 데이터). 보통 반복문과 결합하여 많은 정보를 효율적으로 처리한다. 배열의 인덱스를 이용하여 값을 식별할 수 있으며, 크기가 고정되어있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[0],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[],shiroed1211@gmail.com
52,52,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조. 따라서 인덱스(Index)로 해당 원소에 접근할 수 있으며 Random Access가 가능합니다. 하지만 삽입/삭제 시 해당 원소에 접근하여 작업을 완료한 후 빈 공간이 생기지 않도록 shift 해줘야 하므로 O(N)의 시간이 소요됩니다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",shiroed1211@gmail.com
53,53,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"동일한 자료형의 데이터를 한꺼번에 관리하기 위한 자료구조로 하나의 변수에 여러 데이터를 담을 수 있으며, 반복문을 통해 효율적인 처리가 가능하다. 크기가 정해져있어 바꾸지 못한다는 단점이 있지만, 인덱스를 통해 데이터를 빠르게 조회할 수 있다는 장점이 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[0],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[],mjw8523@gmail.com
54,54,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,같은 타입의 데이터를 나열한 선형 자료구조이다. 연속된 메모리공간에 순차적으로 저장하며 처음 배열을 선언할때의  크기로 고정이되며 한번 지정된 크기는 줄일수도 늘릴수도없다. 인덱스를 가지고 있어 바로 접근이 가능하다. 연속된 메모리공간에 존재하기 때문에 관리가 편하다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],shiroed1211@gmail.com
55,55,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,변수에는 값을 하나 저장할 수 있는데 이런 식으로는 대량의 데이터를 처리하는데 불편합니다. 그래서 거의 모든 언어에서 배열(Array) 자료형을 제공하고 있습니다. 배열에서는 하나의 변수에 여러개의 값을 분리해서 저장할 수 있습니다. 배열의 기본적 아이디어는 같은 데이터 타입을 연속적으로 순서가 있도록 나열하는 것 입니다. ,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[2],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
56,56,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 자료구조에서 가장 일반적인 구조로 메모리상에 형식이 같은 자료 여러 개가 모여 새로운 하나를 이룬 형식이다. 배열은 여러 값을 저장하기 위해 메모리의 연속적인 공간을 차지하고 있다. 배열요소의 인덱스는 0에서부터 전체 요소의 개수보다 1 작은 범위까지이다. 즉, 데이터가 있는 위치(인덱스)만 알고 있다면 바로 해당 메모리에 접근이 가능하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[],shiroed1211@gmail.com
57,57,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 같은 타입의 데이터를 연속적으로 저장한 자료구조입니다. 배열의 특징은 '정적'이라는 점과 '연속적'이라는 것이죠. 정적이라는 말은 처음 배열의 크기가 정해지면 크기를 변경할 수 없음을 뜻합니다. 연속적이라는 건 메모리 상에서 배열의 첫번째 요소는 두번째 요소와 연이어 붙어있다는 것을 말합니다. 즉, 모든 요소들이 저장된 위치는 연속적으로 붙어있습니다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[2],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
58,58,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"연관된 데이터를 하나로 묶어 그루핑해서 관리하기 위해 만들어진 자료구조
배열에서 위치를 가리키는 숫자를 인덱스(Index)라고 부름. 인덱스는 0 부터 시작한다. 참조 객체이며, 배열을 가리키는 참조 변수는 스택(Stack) 영역에 할당된다. 참조 변수가 가리키고 있는 주소값(Address)는 힙(heap)영역에 생성되는 배열의 주소값이다. 인덱스를 통한 접근이 가능하므로 원소를 조회 및 수정할 때 시간복잡도는 O(1)이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[1],shiroed1211@gmail.com
59,59,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"동일한 자료형을 연속적인 메모리 공간에 저장한 자료구조로, 인덱스(index)를 사용하여 임의 접근(Random Access)이 가능하다. 각 항목이 동일한 자료형이므로 동일한 크기를 갖는다. 저장 공간의 크기가 고정적이다. 원소 접근하는데 걸리는 시간이 상수 시간 O(1)이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1]",shiroed1211@gmail.com
60,60,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성, 일관성, 독립성. 지속성. 원자성은 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않거나를 뜻한다.일관성은 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다를 뜻한다. 독립성은 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적임을 의미한다. 지속성은 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 함을 뜻한다. ","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
61,61,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것.
일관성 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것.
독립성 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어 들수 없다는 점.
지속성 트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야 한다는 점","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
62,62,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"ACID는 데이터베이스 트랜젝션이 안전하게 수행된다는 것을 보장하기 위한 트랜잭션의 특징을 말합니다. 원자성 : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다. 일관성 : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다. 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. 영속성 : 트랜잭션이 성공적으로 완료 되었으면 결과는 영구적으로 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
63,63,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"ACID, 원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것. 일관성은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것. 독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점. 지속성은 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
64,64,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,ACID ; 데이터베이스 트랜잭션이 안전하게 수행되는 것을 보장하기 위한 성질을 가리키는 약어. 원자성 : 실행되다가 중단되지 않는 것을 보장. 일관성 : 일관성 있는 데이터베이스 상태로 유지. 독립성 : 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것. 지속성 : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미.,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
65,65,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,트랜잭션은 데이터베이스의 데이터 무결성이 보장되는 상태에서 DML 작업을 완수하기 위한 기본 작업 단위입니다. 관계형 데이터베이스 시스템은 데이터를 처리할 때 트랜잭션을 통해 정상 종료나 사용자 프로세스 실패나 시스템 실패와 같은 비정상 종료에 대해 데이터의 신뢰성과 일관성을 보장합니다.,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[1],"['일관성', '독립성', '지속성', '원자성']",[],shiroed1211@gmail.com
66,66,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성을 보장하려면 4가지 특성 ( ACID )을 만족해야 한다. 원자성은 트랜잭션을 구성하는 연산들이 ‘모두 정상적으로 실행’되거나 ‘하나도 실행되지 않아야 한다’를 의미. 일관성은 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태를 유지. 고립성은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것. 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되야 함을 의미.,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
67,67,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션의 성질을 흔히 ACID 로 표현한다. Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(영속성)의 앞글자를 따 ACID로 트랜잭션의 성질을 표현한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
68,68,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션이란 DBMS (DB) 에서 데이터에 대한 하나의 논리적 실행단계를 의미한다. 여기서 트랜잭션의 4대 특징이란 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질으로, ACID (Atomicity[원자성] / Consistency[일관성] / Isolation[고립성] / Durability[지속성])로 표현된다. 은행과 같이 트랜잭션의 수행이 안전하게 수행됨을 보장해야 하는 시스템에 주로 사용된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
69,69,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션의 중요한 특징은 ACID라는 4가지로 구분됩니다.
원자성 - 데이터베이스에 트랜잭션의 수행이 모두 반영되거나 아예 반영되지 않아야 함
일관성 -트랜잭션이 실행을 성공적으로 완료하면 일관성있는 데이터베이스 상태로 유지해야 함.
독립성 -트랜잭션 수행시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 함.
지속성 -성공적으로 수행된 트랜잭션은 영원히 반영되어야 함. ","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
70,70,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"ACID,
원자성
트랜잭션의 연산은 반드시 모두 반영되도록 완료되거나, 아니면 전혀 반영되지 않도록 복구되어야한다.
일관성
트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
격리성
둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
영속성
성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
71,71,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,트랜잭션에게는 통칭 ACID라는 특징이 있다. 원자성 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 일관성 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 독립성 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 지속성 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
72,72,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션의 특징 (ACID)
원자성 트랜잭션은 한 개 이상의 동작을 논리적으로 한 개의 작업단위로서 분해가 불가능한 최소의 단위
일관성 트랜잭션이 실행을 성공적으로 완료하면 언제나 모순 없이 일관성 있는 데이터베이스 상태를 보존함.
고립성 트랜잭션이 실행 중에 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근할 수 없음.
지속성 성공이 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장됨.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
73,73,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,트랜잭션에는 4가지의 특징이 있습니다. 4가지의 특징의 앞 글 자만 따서 ACID라고도 불립니다. 원자성 -  트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장한다. 일관성 - 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다. 고립성 - 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 한다. 영속성 - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 3]",shiroed1211@gmail.com
74,74,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"ACID
원자성
- 트랜잭션은 DB 작업의 최소 단위가 되어야한다.
일관성
- 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
고립성
- 각각의 트랜잭션은 서로간에 간섭없이 독립적으로 수행되어야 한다.
지속성
- 트랜잭션이 정상적으로 완료된 후에는 영구적으로 데이터베이스에 작업 결과가 저장되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
75,75,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션의 특징은 ACID 특성이라 합니다. 원자성
트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 말합니다.
일관성
트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것을 말합니다.
격리성
트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다.
지속성
성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말합니다","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
76,76,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션은 아래와 같은 특징을 가지며, 영문 첫 글자를 따서  ACID라고 부른다.
원자성
트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.
일관성
트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.
격리성
실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.
영속성
트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
77,77,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위해 여러개의 쿼리를 하나로 묶은 작업의 단위이다. 트랜잭션은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolastion), 지속성(Durability) 4가지 특징을 갖는다. 이 앞글자를 따서 ACID 특징 이라고 부른다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
78,78,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"1. 원자성- 분리 할수 없는 하나의 단위로 작업은 모두 완료되거나, 혹은 모두 취소 되어야 합니다.
2. 일관성- 사용되는 모든 데이터는 일관되어야 합니다.
3. 격리성 - 접근하고 있는 데이터는 다른 트랜잭션으로 부터 격리 되어야 합니다.
4. 영속성- 트랙잭션이 정상 종료되면 그 결과는 시스템에 영구적으로 적용되어야 합니다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
79,79,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성
- 트랜잭션은 분해가 불가능한 최소의 단위로 연산 전체가 처리되거나 처리되지 않아야 한다.
일관성
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 모순 없이 일관성 있는 데이터베이스 상태를 보존
고립성
- 트랜잭션이 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근할 수 없음
지속성
- 성공이 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",shiroed1211@gmail.com
80,80,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락이 발생하기 위한 조건은 크게 4가지로 말할 수 있습니다. 먼저 상호배제는 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 합니다. 점유대기는 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 합니다. 비선점은 이미 할당된 자원을 강제로 빼앗을 수 없다는 조건입니다. 순환대기는 이미 할당된 자원을 강제로 빼앗을 수 없다는 조건입니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
81,81,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"첫번째로 상호배제가 있다. 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
다음으로 점유대기는 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
비선점은 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
순환대기 또한 중요하다. 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이 중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
82,82,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"아래 4가지 조건이 모두 만족되는 경우 데드락이 발생할 가능성이 있다.
하나라도 만족하지 않으면 절대 발생하지 않는다.
상호 배제(Mutual exclusion)는 한 리소스는 한 번에 한 프로세스만이 사용할 수 있음을 뜻함.
점유와 대기(Hold and wait)는 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리고 있음을 뜻함.
비선점(No preemption)은
프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할 때까지 기다린다는 뜻임. (강제로 빼앗지 않는다)
환형 대기(Circular wait)는 Hold and wait 관계의 프로세스들이 서로를 기다린다는 조건임.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
83,83,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"교착 상태는 한 시스템 내에서 다음의 4가지 조건이 동시에 성립할 때 발생한다.


상호 배제(Mutual Exclusion)

: 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

점유 대기 (Hold and Wait)

: 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

즉, 이미 자원을 사용중인데, 다른 프로세스가 사용중인 자원을 사용하기 위해 대기하고 있는 상태의 프로세스가 존재해야 한다.

비선점 (No preemption)

: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

순환 대기 (Circular wait)

: 프로세스의 집합에서 P0은 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고, P2...Pn-1d은 Pn이 점유한 자원을 대기하며 Pn은 P0이 점유한 자원을 요구해야 한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
84,84,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"Mutual Exclusion(상호 배타적)
하나의 프로세스가
자원을 독점적으로 사용한다(여러 개가 동시 사용 불가)
No preemption
프로세스가 자원을 가지고 있을 때, 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
Hold and wait
자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
Circular wait
자원을 기다리는 프로세스간에 사이클이 형성되어야 함
프로세스 P0, P1, ... , Pn이 있을 때 Pn-1은 Pn의 자원을 기다리고 Pn은 P0의 자원을 기다려야 한다","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
85,85,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"교착상태는 아래의 4가지 조건이 모두 만족되는 경우(필요충분조건)에 발생할 가능성이 있으며,
하나라도 만족하지 않으면 교착상태가 발생하지 않습니다.



1. 상호 배제(Mutual Exclusion)
한 번에 한 개의 프로세스만이 공유자원을 사용할 수 있음

2. 점유 대기(Hold and Wait)
프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림

3. 비선점(No Preemption)
프로세스가 작업을 마친 후 자원을 자발적으로 반환할 때까지 기다림
(이미 할당된 자원을 강제적으로 빼앗을 수 없음)

4. 순환 대기(Circular Wait)
프로세스의 자원 점유 및 점유된 자원의 요구 관계가 원형을 이루면서 대기하는 조건.
각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
86,86,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,몇가지 조건을 모두 만족하면 데드락이 발생할 가능성이 있다. 하나라도 해결되면 발생하지 않는다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],alsxmqkqh23@gmail.com
87,87,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점, 순환 대기","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
88,88,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"4가지 모두 성립해야 데드락 발생 (하나라도 성립하지 않으면 데드락 문제 해결 가능)
자원은 한번에 한 프로세스만 사용할 수 있음 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],alsxmqkqh23@gmail.com
89,89,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"하나라도 만족하지 않으면 데드락은 해결된다.
상호 배제 Mutal exclusion
자원은 한번에 하나의 프로세스만 사용할 수 있다.
하나의 자원을 두 개 이상의 스레드가 점유할 수 없다.
비선점 No preemption
어떤 자원은 그 자원을 점유한 프로세스가 task을 완료 했을 때, 그 프로세스에 의해 자발적으로만 방출된다. 중간에 다른 프로세스가 강제로 뺏을 수 없다.
점유 대기 Hold and wait
어떤 프로세스는 적어도 하나의 자원을 점유한 상태에서 다른 프로세스에 의해 점유된 다른 자원을 추가적으로 얻기를 기다리고 있어야 한다.
순환 대기 Circular wait
스레드와 자원이 순환적으로 꼬리를 물고 기다리는 구조이다. ","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
90,90,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"식사하는 철학자 문제
5명의 철학자와 5개의포크가 있고 식사를위해서는 한사람당 두 개의 포크가 필요한 상황이다.
한 개의 포크를 두 명 의 철학자가 동시에 사용할 수 없고 (mutual exclusion)
한 철학자는 각각 왼쪽 포크를 가진 상태로 오른쪽 포크를 기다린다. (Hold and wait)
또 철학자는 이미 다른 철학자가 가지고 있는 포크를 빼앗을 수 없다 (No preemption)
원형 테이블이므로 순환 구조를 가진다 (Circular wait)","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
91,91,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
점유대기: 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
비선점 : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
순환대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
92,92,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호배제는 젓가락은 한번에 한 철학자만 사용 가능하다는 점이다.
보유 및 대기는 집어든 젓가락을 계속 들은 채로 반대쪽 젓가락을 기다리는 내용이다.
비선점은 이미 누군가 쥐고있는 젓가락을 뺏을 수 없다.
환형 대기는 모든 철학자는 자신의 오른쪽 철학자가 젓가락을 내려놓기를 기다린다는 내용이다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
93,93,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기
  위해 대기하는 프로세스가 있어야 한다.
 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],alsxmqkqh23@gmail.com
94,94,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"한 리소스는 한 번에 한 프로세스만 사용할 수 있다. 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리고 있다. 프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할때까지 기다린다.(강제로 빼앗지 않는다)
Hold and wait 관계의 프로세스들이 서로 기다린다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[1],alsxmqkqh23@gmail.com
95,95,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"소한 하나의 자원은 비공유방식(nonsharable mode)으로 점유되어야한다. 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다. 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다. 프로세스의 집합 {P0,P1,...,Pn에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2...Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],alsxmqkqh23@gmail.com
96,96,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"교착상태가 발생하기 위해서는 4가지 조건이 만족해야 합니다.
첫번째는 상호 배제로 한 리소스는 한번에 한 프로세스만이 사용할 수 있다.
두번째는 점유와 대기로 어떤 프로세스가 하나의 리소스를 점유하는 동시에 다른 프로세스가 해당 리소스를 기다린다.
세번째는 비선점으로 프로세스가 태스크를 선점하지 않고 반환할 때까지 기다린다.
네번째는 환형 대기로 프로세스들이 서로를 기다린다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
97,97,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제는 프로세스가 자원을 사용할 때 다른 프로세스와 동시에 사용할 수 없는 조건을 의미합니다.
두번째로 점유 및 대기는
한 자원을 점유한 상태에서 다른 자원을 요청하기 위해 대기할 수 있는 조건을 의미합니다. 비선점은
한 프로세스가 자원을 할당 받으면 작업이 끝날 때 까지 시스템에서 제어권을 뺏을 수 없는 조건을 의미합니다.
순환 대기는 여러개의 프로세스가 서로의 자원을 요청하고 있는 상태를 의미합니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
98,98,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"다음 4가지를 모두 만족하여야 교착상태가 발생할 수 있다.
1.
상호 배제 (mutual exclusion)
프로세스가 자원을 사용할 때 다른 프로세스와 동시에 사용할 수 없는 조건을 의미한다.
2.
점유 및 대기 (hold and wait)
한 자원을 점유한 상태에서 다른 자원을 요청하기 위해 대기할 수 있는 조건을 의미한다.
3.
비선점 (nopreemption)
한 프로세스가 자원을 할당 받으면 작업이 끝날 때 까지 시스템에서 제어권을 뺏을 수 없는 조건을 의미한다.
4.
순환 대기 (circular-wait)
여러개의 프로세스가 서로의 자원을 요청하고 있는 상태를 의미한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1, 2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",alsxmqkqh23@gmail.com
99,99,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락이 발생하는 상황은 다음과 같다.

멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
한 프로세스가 자원을 요청했고 동시에 그 자원을 사용할 수 없는 상황이 발생할때 해당 프로세스는 대기 상태로 들어간다.
대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때의 상황을 교착상태(DeadLock)라고 한다.
","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],alsxmqkqh23@gmail.com
100,100,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"기본 키는 주 키 또는 프라이머리 키라고 하며, 관계형 데이터베이스에서 조(레코드)의 식별자로 이용하기에 가장 적합한 것을 관계 (테이블)마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다. ","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 3]","['대표성', '후보키', '유일성, unique', nan]",[],alsxmqkqh23@gmail.com
101,101,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 후보키 중에서 선택한 주키(Main Key)이다. 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. Null값을 가질 수 없다. 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2, 3]","['대표성', '후보키', '유일성, unique', nan]",[1],alsxmqkqh23@gmail.com
102,102,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"기본키는 주 키 또는 프라이머리 키라고 하며, 후보키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없으며, 후보키의 성질을 갖는다. 즉, 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다. ","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 3]","['대표성', '후보키', '유일성, unique', nan]",[1],alsxmqkqh23@gmail.com
103,103,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 릴레이션을 대표하는 키다. 때문에 기본키를 설정하면 다른 릴레이션의 외래키와 관계를 맺고 상호작용 할 수 있다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[0],alsxmqkqh23@gmail.com
104,104,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,후보키 중에서 선택한 주키(Main Key)로 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성을 가지며 Null 값을 가질 수 없습니다,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2, 3]","['대표성', '후보키', '유일성, unique', nan]",[1],alsxmqkqh23@gmail.com
105,105,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 후보키 중에서 특별히 선정된 주키(Main Key)이며 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키는 중복된 값을 가질 수 없으며 NULL값을 가질 수 없다,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2, 3]","['대표성', '후보키', '유일성, unique', nan]",[1],alsxmqkqh23@gmail.com
106,106,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"기본키는 DB에서 Primary Key라고 부릅니다.
이걸 정하는 이유는 데이터를 보다 명확하게 구분하고 찾기 위해서죠.","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],alsxmqkqh23@gmail.com
107,107,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,후보 키 중에서 레코드들의 식별자로 선택한 하나의 키,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
108,108,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 후보키 중 하나를 선정하여 대표로 삼는 키를 말한다. 후보키가 하나뿐이라면 그 후보키를 기본키로 사용하면 되고 여러 개라면 릴레이션의 특성을 반영하여 하나를 선택하면 된다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
109,109,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족하는 속성이다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
110,110,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키 역시 DBMS에서 테이블에 설정하는 하나의 제약 조건 중 하나입니다. 기본키 제약 조건은 테이블 내에서 유일하게 존재하는 값의 조합을 설정해서 중복된 데이터가 테이블에 삽입되는 것을 방지하는 제약 조건입니다,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
111,111,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"설계자가 여러 후보키 중 하나를 선택하여 정의한 식별자 (유일성, 최소성)기본키의 모든 필드의 값은 null 이 될 수 없다.","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[2],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
112,112,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"각 행마다 행을 식별할 수 있도록 전부 다른 값이 저장된 열을 찾으셨다면, 그 열을 가지고 기본 키를 만들 수 있습니다. 다시 한번 강조하자면, 기본 키는 테이블 내의 각 행을 고유하게 하는 열입니다. 고로, 기본 키는 모든 행이 고유한 값을 가지고 있는지 혹은 값이 비어있는 행이 있는지 확인할 수 있도록 합니다. 예를 들어, 여러분이 이미 어떤 열에 존재하는 값을 새로운 행을 만들어서 추가하고자 한다면, 이는 기본 키에 의해서 생성이 제한됩니다.

또한, 기본 키는 NULL 값을 받아들이지 않습니다. 즉, 기본 키 열에는 NULL 값이 존재할 수 없습니다. 미국 시민의 정보를 저장하고 있는 테이블인 citizen 예시가 기억나십니까? 만약 social_security_number 열에 NULL 값이 포함된 행을 추가하고자 한다면, 이는 기본 키에 의해서 제지 당합니다. 다시 말해서, 기본 키는 기본 키가 되는 열의 행 값이 고유하고 비어있지 않도록 만들어 줍니다.","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2]","['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
113,113,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키(Primary Key)는 관계형 데이터 베이스에서 식별자로 사용하기 위해 테이블마다 하나씩 존재하는 데이터를 말합니다. 기본키가 될 수 있는 컬럼들을 후보 키(Candidate Key)라고 하며 기본키는 후보 키들 중 하나를 선택한 컬럼이라고 할 수 있습니다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
114,114,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"PRIMARY KEY 제약 조건을 설정하면, 해당 필드는 NOT NULL과 UNIQUE 제약 조건의 특징을 모두 가집니다.

따라서 이 제약 조건이 설정된 필드는 NULL 값을 가질 수 없으며, 또한 중복된 값을 가져서도 안 됩니다.

이러한 PRIMARY KEY 제약 조건을 기본 키라고 합니다.","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
115,115,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,후보키는 여러개가 존재할 수 있는데 여기서 우리는 여러 후보키 중에서 하나를 선택해서 사용해야 하며 여기서 선택된 키가 기본키입니다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
116,116,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,후보키(candidate key)중 데이터베이스 설계자가 선정하는 하나의 키,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
117,117,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"기본키(primary key)는 여러 후보키 중 하나를 선정해 대표로 삼는 키.
후보키가 하나뿐이라면 그 후보키를 기본키로 사용하면 되고 여러 개라면 릴레이션의 특성을 반영해 하나 선택하면 됨.

기본키는 릴레이션을 대표하므로 여러 사항을 고려해야 한다.
예를 들어 저자 릴레이션의 경우 '저자번호', 'URL'을 기본키로 선택할 수 있다. 먼저 URL을 보면, 저자에게 각각 주어지며 변경이 불가능하다. 변경이 불가능하면 튜플 식별 시 자료변형에 잘 대처할 수 있는 여지를 제공.
그러나 URL은 속성의 값이 다른 데이터에 비해 큰 편이라 데이터 계산 속도에 영향을 줄 수 있다.
따라서 기본키로 저자번호를 선택하는 것이 좋다.","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[3, 4]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
118,118,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
119,119,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,여러 후보키 중 대표적인 키 하나를 선택해 테이블의 기본 키로 만든다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[0],mjw8523@gmail.com
120,120,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 브라우저에 저장하기 때문에 유실, 변조, 도난되기 쉽습니다. 그에 반해 세션은 서버 측에 관리 되기 때문에 위와 같은 위험이 적습니다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
121,121,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,여러번 실행시켜도 그 결과가 동일한 것을 멱등성이라고 부른다. http 메서드에서도 여러번 반복해서 요청했을 때 항상 동일한 결과를 내는 메서드는 idempotent한 http메서드라고 부른다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
122,122,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,"기본키는 다른 항목과 절대로 중복되어 나타날 수 없는 단일 값을 나타냅니다. 하나 이상의 컬럼이 그룹화된 것도 기본키로 사용할 수 있습니다.
","['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
123,123,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[0],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
124,124,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키와 세션이 반대되는 개념으로 알고있는 사람이 많지만 사실 세션을 이용해 로그인 할 때 쿠키를 함께 이용합니다. 세션아이디를 쿠키에 담아서 통신하기 때문에 상호보완적 관계라고 볼 수 있습니다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[],"['라이프사이클', '보안', '저장위치', '속도']",[],mjw8523@gmail.com
125,125,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다. 다만 서버가 REST API를 잘 다랐다는 전제하에 멱등성 제약이 보장된다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
126,126,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 단일값이면서 Null 값을 가지지 않는 키입니다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
127,127,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[3],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
128,128,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트에 파일로 저장되고 세션은 서버에 저장된다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
129,129,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성은 요청의 효과를 보고 판단한다. 같은 행위를 여러번 반복하더라도 같은 효과를 가져야한다. 많이 쓰이는 http method중 POST를 제외한 GET, PUT, DELETE가 멱등성이 보장되고, 그 외 method로는 OPTIONS, HEAD등이 있다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
130,130,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키란 행을 고유하게 구분해주는 최소의 정보입니다. 모든 테이블은 기본키를 가져야하며 하나의 기본키만을 가져야 합니다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 1]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
131,131,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,이미 할당된 자원을 강제로 빼앗을 수 없다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[1],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
132,132,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스나이핑당할 우려가 있어서 보안이 취약하다. 반면 세션은 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 안전하다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
133,133,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. get은 여러 번 호출해도 클라이언트는 동일한 응답을 받지만 post는 여러 번 호출할 경우 여러 열이 추가된다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
134,134,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 여러 후보키 중에서 하나를 선택해서 사용합니다. ,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
135,135,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[2],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[2],mjw8523@gmail.com
136,136,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키에 만료시간은 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 만료기간을 넉넉히 잡아두면 쿠키를 삭제 할 때까지 유지될수도 있다.
세션은 만료기간을 정할수는 있지만 브라우저가 종료되면 그에 상관없이 삭제된다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']","[0, 2]",mjw8523@gmail.com
137,137,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다. 멱등성이 성립하는 메소드는 통계 기록을 제외하면 어떠한 side effect도 존재해서는 안된다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
138,138,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 각 컬럼을 구분해주는 키를 말한다. 테이블은 기본키를 하나까지만 가질 수 있다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
139,139,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점, 순환 대기","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
140,140,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 서버의 DB에 연결할 필요가 없기 때문에 요청시 속도가 빠르다. 세션은 정보가 서버에 있기 때문에 DB에 접근해야 해서 비교적으로 느리다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[2, 3]",mjw8523@gmail.com
141,141,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. 멱등성을 따질 때에는 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있다. REST API에서 개발자는 DELETE메서드를 사용해 ""목록의 마지막 항목을 제거하기"" 기능을 구현해서는 안 된다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[1],mjw8523@gmail.com
142,142,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,고유값을 가지는 후보키들 중에서 레코드를 가장 잘 대표하는 하나를 골라 기본키로 선정하여 사용한다. 값이 꼭 존재해야 하고 구분을 위한 고유값을 가져야 한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 3]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
143,143,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점 등이 있다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 3]",mjw8523@gmail.com
144,144,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트에 파일로 저장되고 세션은 서버에 저장된다. 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스나이핑당할 우려가 있어서 보안이 취약하다. 반면 세션은 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 안전하다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2]",mjw8523@gmail.com
145,145,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 역속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
146,146,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 대표성을 가지며 자주 참조되어야 한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
147,147,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,프로세스 하나만이 하나의 자원을 사용할 수 있고 다른 프로세스는 이를 기다려야 한다. 또한 각각의 프로세스가 자원을 하나씩 보유하고 다른 프로세스의 자원에 대해 대기해야 한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
148,148,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키에 만료시간은 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 만료기간을 넉넉히 잡아두면 쿠키를 삭제 할 때까지 유지될수도 있다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']",[0],mjw8523@gmail.com
149,149,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 역속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다. 보통 Http 메서드의 GET, POST, PUT, HEAD, DELETE 중 POST 를 제외한 GET, HEAD, PUT, DELETE는 멱등성을 가진다고 말합니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
150,150,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 상징성을 가지며 가급적 짧으면 유리하다. 테이블간의 연결고리로 사용하기 때문이다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
151,151,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,다른 프로세스에 할당된 자원은 빼앗을 수 없어야 한다. 또한 서로 순환되는 형태로 자원에 대해 대기해야 한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[1, 2]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
152,152,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,세션은 만료기간을 정할수는 있지만 브라우저가 종료되면 그에 상관없이 삭제된다. 쿠키는 서버의 DB에 연결할 필요가 없기 때문에 요청시 속도가 빠르다. 세션은 정보가 서버에 있기 때문에 DB에 접근해야 해서 비교적으로 느리다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2, 3]","['라이프사이클', '보안', '저장위치', '속도']","[0, 2, 3]",mjw8523@gmail.com
153,153,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"동일한 요청을 한 번 보내는 것과 여러 번 역속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
POST는 리소스의 생성을 의미하기 때문에 요청이 반복되면 리소스가 계속 생성이 되는 것이기 때문에 멱등성을 만족하지 못하고 GET, PUT, DELETE 등은 여러번 요청해도 서버 상태가 변하지 않기 때문에 멱등성을 가진다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
154,154,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 여러 후보키 중에서 선택하여 무엇이든 사용할 수 있지만 가장 적합한 것으로 고르는 것이 좋다. 고유한 값을 가지되 대표성을 가지면 좋다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[3],"['대표성', '후보키', '유일성, unique', nan]","[0, 1]",mjw8523@gmail.com
155,155,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,다른 프로세스가 사용 중인 자원은 다른 프로세스가 사용할 수 없다는 조건을 만족해야 한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
156,156,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"정보가 유지되지 않으면, 매번 페이지를 이동할 때마다 로그인을 다시 하거나, 상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 없거나 하는 등의 일이 발생할 수 있다. 따라서, Stateful 경우를 대처하기 위해 쿠키와 세션을 사용한다. 쿠키와 세션의 차이점은 크게 상태 정보의 저장 위치이다. 쿠키는 '클라이언트(=로컬PC)'에 저장하고, 세션은 '서버'에 저장한다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
157,157,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등은 한번 호출하든 두 번 호출하든 1억 번 호출하든 결과가 똑같이 나온다. 멱등성을 가진 HTTP 주요 메서드는 GET, PUT, DELETE 방식이다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
158,158,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,레코드를 유일하게 식별할 수 있는 컬럼을 의미한다. 테이블에 저장된 레코드를 사용하기 위해서는 각각의 레코드를 구별할 수 있는 방법이 필요한데 이때 사용한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
159,159,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,다른 프로세스의 자원을 사용할 수 없고 그것을 기다리고 있는 상태인데 이를 빼앗을 수 없으며 상대 프로세스도 내것을 기다리고 있을 때 발생한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[1, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
160,160,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷하다. 그 이유는 세션도 결국 쿠키를 사용하기 때문이다. 큰 차이점은 사용자의 정보가 저장되는 위치이다. 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용한다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
161,161,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성이란 수학에서 사용하는 용어에서 유래한 것으로 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 뜻합니다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
162,162,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 후보키들 중 하나로 외래키를 사용할 때 다른 테이블의 기본키를 선정하므로 중요하다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
163,163,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,각 프로세스가 하나의 자원만 사용할 수 있는데 서로 하나씩 가지고 있는 상태에서 서로의 자원에 대기중이라면 데드락이 발생할 수 있다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[2, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
164,164,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,보안 면에서 세션은 쿠키에 비해 더 우수하다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[0],"['라이프사이클', '보안', '저장위치', '속도']",[1],mjw8523@gmail.com
165,165,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 동일한 요청을 한 번 보내는 것과 여러 번 연속적으로 보내는 것이 같은 효과를 지니고 서버의 상태도 동일하게 남을 때 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']","[0, 1]",mjw8523@gmail.com
166,166,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,각각의 레코드를 구분할 때 사용한다. 빠른 속도로 레코드를 찾을 때 필요하다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
167,167,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 각 프로세스가 순환 형태로 자원을 대기한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 2]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
168,168,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"라이프 사이클은 쿠키도 만료기간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 정보가 유지될 수 있다. 또한 만료기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수도 있다 반면에 세션도 만료기간을 정할 수 있지만, 브라우저가 종료되면 만료기간에 상관없이 삭제된다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[3],"['라이프사이클', '보안', '저장위치', '속도']",[0],mjw8523@gmail.com
169,169,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 수학에서 사용하는 용어에서 유래한 것으로 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 뜻합니다. HTTP 메서드 GET, POST, PUT, DELETE 중 POST를 제외하고는 모두 멱등성이 보장되어야 합니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
170,170,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 데이터베이스에서 테이블의 식별자로 사용되는 키이다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
171,171,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점, 순환 대기를 모두 만족해야 한다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
172,172,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[2, 3]",mjw8523@gmail.com
173,173,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 요청의 효과를 보고 판단합니다. 서버의 상태가 멱등성이 유지되어야 하는 경우 같은 행위를 여러번 반복하더라도 같은 효과를 가져야 합니다. 멱등성이 성립하지 않으면 같은 행위를 여러번 반복하더라도 각 요청마다 다른 효과가 발생하게 됩니다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
174,174,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 테이블을 설계하여 사용할 때 해당 테이블을 고유하게 식별하는 키를 의미한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
175,175,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호배제, 점유 대기 등의 네가지 조건이 있는데 이를 모두 만족해야 한다. 하나라도 만족하지 않으면 데드락은 발생하지 않는다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1]",mjw8523@gmail.com
176,176,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"세션이 쿠키에 비해 보안이 높은 편이나 쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버의 자원을 사용하기에 서버 자원에 한계가 있고, 속도가 느려질 수 있기 때문에 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여 서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2, 3]",mjw8523@gmail.com
177,177,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 연산을 여러번 적용해도 값이 달라지지 않음을 뜻한다. Http method에서 idempotent의 특성을 갖는 요청들은 요청에 따라 같은 결과를 요한다고 생각하면 될 것 같다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
178,178,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 각 레코드마다 유일하다. 그렇기때문에 중요하게 선택되어야 한다. 유일한 값을 가지고 NULL이 되어서는 안된다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
179,179,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,프로세스 하나만이 하나의 자원을 사용할 수 있고 각 프로세스는 자원을 최소 하나 보유한 상태이며 이를 빼앗을 수 없는 경우에 발생한다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 1]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
180,180,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키와 세션은 서버가 stateful한 경우를 대처하기 위해 사용한다. 쿠키와 세션의 차이점은 크게 상태 정보의 저장 위치이다. 쿠키는 클라이언트 브라우저에 저장하고 세션은 서버에 저장한다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
181,181,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,HTTP의 멱등이란 같은 요청이면 반환되는 모든 응답이 모두 동일함을 의미합니다. POST 요청은 요청할때마다 서버의 리소스를 생성하거나 업데이트하므로 멱등성이 보장되지 않습니다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
182,182,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 각 행마다 유일하다. 테이블에서 가장 먼저 고려하는 식별자로 사용한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
183,183,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,하나의 자원은 하나의 프로세스에서만 사용할 수 있고 각각의 프로세스에서 서로의 자원에 대해 대기하는 상태일때 발생합니다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']","[0, 3]","['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
184,184,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트 측 로컬 브라우저에 저장되는 key-value쌍의 작은 데이터이고 세션은 로그인 정보를 서버에 저장하여 로그인을 시켜준다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
185,185,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성이란 어떤 대상에 같은 연산을 여러번 적용해도 결과가 달라지지 않는 성질이다. ,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
186,186,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 개별 행을 검색하는데 사용하는 고유한 키이다. 다른 행과 구별되는 중복없는 키이다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
187,187,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,서로 순환하는 형태로 자원에 대해 대기할 때 데드락이 발생할 수 있습니다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[2],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[],mjw8523@gmail.com
188,188,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 클라이언트 측 로컬 브라우저에 저장되는 Key-value쌍의 작은 데이터이다. 이후 클라이언트가 데이터를 요청 시, header에 쿠키를 넣어 서버에 보내게 되고, 서버가 쿠키를 읽어 사용자를 식별한다. 로그인 정보가 쿠키에 담겨 있다면, 더 이상의 인증은 필요 없게 된다. 그에 반해 세션은 브라우저가 종료되기 전까지 클라이언트의 요청을 유지시킨다. 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 서버에서 관리한다. 세션의 내용은 서버에 저장되기 때문에 사용자가 많아질수록 서버 메모리를 많이 차지한다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']","[0, 2]",mjw8523@gmail.com
189,189,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등성은 API 요청이 한 번만 완료되도록 합니다. 멱등성 요청에서는 원래 요청이 성공적으로 완료된 경우 후속 재시도에서 원래 성공한 요청의 결과를 반환하며 추가 영향이 없습니다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
190,190,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 관계형 데이터베이스에서 각 행을 고유하게 식별해주는 키이다. 대표성과 고유성을 가진다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]","[0, 1]",mjw8523@gmail.com
191,191,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락은 상호 배제, 점유 대기, 비선점, 순환 대기 등을 만족하면 발생합니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
192,192,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키와 세션의 차이점으로 저장 위치, 보안, lifecycle, 속도가 있다.
쿠키는 로컬에, 세션은 로컬과 서버에 저장된다.
쿠키는 탈취와 변조가 가능하지만, 세션은 ID값만 가지고 있고 서버에도 저장이 되어있기 때문에 상대적으로 안전하다.
쿠키는 브라우저를 종료해도 파일로 남아있지만, 세션은 브라우저 종료 시 세션을 삭제한다.
쿠키는 파일에서 읽기 때문에 상대적으로 빠르고, 세션은 요청마다 서버에서 처리를 해야 하기 때문에 비교적 느리다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1, 2, 3]","['라이프사이클', '보안', '저장위치', '속도']","[0, 1, 2, 3]",mjw8523@gmail.com
193,193,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. 동일 요청은 동일 응답을 가져야 한다는 의미가 아니며, 요청으로 어떤 부작용도 발생하지 말아야 한다는 의미가 아님에 유의해야 한다. GET은 멱등 메서드지만, POST는 멱등 메서드가 아니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
194,194,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 유일하며 NULL값을 갖지 않고 변경되지 않는 키이다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[2, 4]","['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
195,195,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락의 발생조건에는 상호 배제, 점유 대기, 비선점, 순환 대기 등이 있습니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
196,196,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키와 세션은 비슷한 역활을 합니다. 동작원리 또한 비슷 합니다. 왜냐하면 세션도 결국 쿠키로 저장해서 사용하기 때문입니다.
그러나 큰 차이점은 저장되는 위치 입니다. 쿠키는 클라이언트에 저장되어서 보내는 역활을 하고, 세션은 서버에 저장되어서 클라이언트에게 알려줘서 사용 합니다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
197,197,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"연산을 여러번 적용하더라도 결과가 달라지지 않는 즉, 항상 같은 결과를 말한다. POST의 연산의 경우에는 리소스를 새로 추가하는 CREATE에 해당하는 연산이기 때문에 Idempotence(멱등성)을 가지지 않습니다. 하지만 GET, PUT, DELETE에 해당하는 메서드는 항상 멱등성을 가지고 있어야 합니다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
198,198,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 유일한 값으로 행을 식별한다. 보통 숫자를 자동생성해서 사용하는 경우가 많다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
199,199,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락은 상호 배제, 점유 대기, 비선점, 순환 대기를 모두 만족했을 때 발생합니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
200,200,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,"쿠키는 서버의 자원을 전혀 사용하지 않습니다. 클라이언트 단에서 저장을 해서 사용하기 때문입니다.
세션은 서버에 저장되어서 그 고유한 ID를 가지고 있습니다. 그래서 서버의 자원을 사용합니다.","['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
201,201,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 여러번 연산해도 결과가 달라지지 않는 성질이며 GET, HEAD와 같이 서버측의 상태 정보를 변경하지 않는 메소드이다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']","[0, 1]","['동일한 요청', '상태']",[1],mjw8523@gmail.com
202,202,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 테이블설계시 각 행을 고유하게 식별할 수 있는 키를 의미한다. ,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
203,203,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"네가지 조건인 상호 배제, 점유 대기, 비선점, 순환 대기를 모두 만족시켰을 때 발생하게 됩니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
204,204,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트에 저장되어서 서버에 요청시 빠른 속도를 냅니다. 세션은 서버에 정보가 있기 때문에 서버의 처리가 필요해서 쿠키보다 느린 속도를 냅니다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[2, 3]",mjw8523@gmail.com
205,205,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"멱등성이란 여러번 수행해도 결과가 같음을 의미한다.
HTTP 메소드를 예를 들자면, GET, PUT, DELETE는 같은 경로로 여러 번 호출해도 결과가 같다. 그러나 POST는 매 호출마다 새로운 데이터가 추가된다. 따라서 POST는 결과가 Idempotent하지 않지만, PUT은 반복 수행해도 그 결과가 Idempotent하다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
206,206,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 데이터베이스에서 테이블을 설계할 때 꼭 필요한 존재이다. 유일한 값을 가지며 NULL값을 가질 수 없다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']","[0, 2]","['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
207,207,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,데드락은 프로세스가 자원을 보유한 상태로 다른 프로세스의 자원을 점유하기 위해 대기할 때 발생합니다.,"['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[3],"['상호 배제', '점유 대기', '순환 대기', '비선점']",[1],mjw8523@gmail.com
208,208,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,세션은 서버에 저장되기 때문에 서버에 처리를 요구하는 부하와 저장 공간을 필요로 합니다. 그러나 쿠키는 클라이언트의 브라우저에 저장하기 때문에 저장 공간을 클라이언트가 부단하고 부하도 덜 합니다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']",[2],"['라이프사이클', '보안', '저장위치', '속도']",[2],mjw8523@gmail.com
209,209,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,멱등한 HTTP 메서드는 몇 번을 호출되더라도 동일한 결과를 리턴하는 메서드를 말한다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[],mjw8523@gmail.com
210,210,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 특정 컬럼 내에 데이터가 유일하도록 보장해주는데 사용된다. 테이블 내에 하나만 존재한다.,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
211,211,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"데드락이 발생하기 위한 조건 네가지는 상호 배제, 점유 대기, 비선점, 순환 대기 등이 있다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
212,212,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트측에 저장이 되지만 매 요청마다 헤더에 실려 서버로 전속이 된다. 만약 쿠키에 저장된 정보가 많다면 매번 요청마다 큰 공간적 오버헤드가 발생할 것이다. 그래서 쿠키의 데이터는 4kb로 제한이 되어 있다. 세션은 서버측에 정보를 저장하기 때문에 요청에 대한 공간적 오버헤드는 없지만 세션 DB에 접근해야 하기 때문에 유저가 많아지고 요청이 많아지면 처리 시간에 대한 오버헤드가 발생할 수 있다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[2, 3]",mjw8523@gmail.com
213,213,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,"GET 메소드는 여러 번 호출해도 타킷 리소스는 동일한 응답을 하므로, PUT 메소드는 동일한 리소스를 업데이트하고 이후에도 그 결과가 달라지지 않으므로 멱등하다.","['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
214,214,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 관계형 데이터베이스 테이블 내에 기록을 유일하게 식별하는 역할을 한다. 유니크하며 ,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[],mjw8523@gmail.com
215,215,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점, 순환 대기","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
216,216,7,[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,jack,쿠키는 클라이언트측에 저장이 되고 세션은 서버측에 저장이 된다. 그렇기 때문에 쿠키에 로그인 정보를 담아 통신하는 경우 쿠키가 탈취당했을 시에 보안적으로 위험하다. 그러나 세션은 서버에 저장을 하기 때문에 중간에 탈취를 당할 위험이 없다. 그러나 서버에 따로 저장을 하고 DB에 접근해야 하기 때문에 오버헤드가 발생할 수 있다.,"['세션이 쿠키보다 보안에 유리하다.', '세션이 쿠키보다 속도가 느리다.', '쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.', '세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.']","[0, 1, 2]","['라이프사이클', '보안', '저장위치', '속도']","[1, 2, 3]",mjw8523@gmail.com
217,217,2,[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,jack,GET은 여러 번 호출해도 동일한 응답을 하므로 멱등하다. 그러나 POST는 복수 호출 시 각기 다른 결과가 리턴되거나 새로운 리소스가 계속 만들어질 수 있으므로 멱등하지 않다. DELETE는 처음에 리소스가 삭제되면 더 이상 존재하지 않고 여러 번 호출해도 결과가 달라지지 않기에 멱등하다.,"['서버가 상태가 요청후에도 동일하다.', '동일한 요청을 여러번 해도 결과가 바뀌지 않는다.']",[1],"['동일한 요청', '상태']",[0],mjw8523@gmail.com
218,218,5,[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,big jo,기본키는 특정 행의 데이터가 유일하다는 것을 보장해주는 역할을 하는 키이다. ,"['특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.', '키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.', 'NULL 값을 가질 수 없다.', '후보키 중 엔티티를 대표할 수 있는 키이다.', '자주 변경되지 않아야 한다.']",[0],"['대표성', '후보키', '유일성, unique', nan]",[1],mjw8523@gmail.com
219,219,9,[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,big jo,"상호 배제, 점유 대기, 비선점, 순환 대기의 네가지 조건이 있습니다.","['한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ', '이미 할당된 자원을 강제로 빼앗을 수 없다.', '대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.', '자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.']",[],"['상호 배제', '점유 대기', '순환 대기', '비선점']","[0, 1, 2, 3]",mjw8523@gmail.com
220,220,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 같은 타입의 데이터를 여러개 나열한 선형 자료구조이며, 연속적인 메모리 공간에 순차적으로 데이터를 저장합니다.
배열은 선언할 때 크기를 정하면, 그 크기로 고정이 된다. 선언된 값은 다시 배열을 선언하지 않으면 변경할 수 없다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[2],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
221,221,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Automicity)
트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다. (All or Nothing)

일관성(Consistency)
트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면
트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.

고립성(Isolation)
트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.

지속성(Durability)
트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
222,222,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"같은 자료형을 가진 변수를 하나로 나타낸 것이다. 연속된 메모리 공간으로 이루어져있으며, 정적 표현이다. 인덱스를 이용하여 표현한다. 지역성을 갖고 있어서 인덱스를 통한 검색이 용이하며 연속적이기때문에 메모리 관리가 편하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
223,223,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션이 신뢰를 가지기 위해 다음과 같은 특성을 가진다.원자성(Atomicity)트랜잭션에 포함된 명령들은 모두 수행되거나, 모두 수행 안되어야 한다. 즉 어느 명령은 실행되고 어느 명령은 실행되지 않으면 안된다.일관성(Consistancy)트랜잭션이 완료된 뒤에는 일관적인 상태에 있어야 한다. 트랜잭션의 영향이 한 방향으로만 전달되어야 한다.고립성(Isolation)트랜잭션은 다른 트랜잭션과 독립적으로 실행되는 것 처럼 보여야 한다. 트랜잭션의 부분상태를 다른 트랜잭션에 제공해서는 안된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 3]",mjw8523@gmail.com
224,224,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,배열은 실제 메모리 상에서 메모리가 순차적으로 저장된다. 따라서 어느 위치에 있는지 인덱스로 손쉽게 접근할수 있는 것이다. 배열은 인덱스를 사용해서 무작위 접근(random access)가 가능하여 검색 성능이 빠르다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",mjw8523@gmail.com
225,225,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션이 신뢰를 가지기 위해 다음과 같은 특성을 가진다.원자성(Atomicity)트랜잭션에 포함된 명령들은 모두 수행되거나, 모두 수행 안되어야 한다. 즉 어느 명령은 실행되고 어느 명령은 실행되지 않으면 안된다. 고립성(Isolation)트랜잭션은 다른 트랜잭션과 독립적으로 실행되는 것 처럼 보여야 한다. 트랜잭션의 부분상태를 다른 트랜잭션에 제공해서는 안된다. 지속성(Durability)트랜잭션의 결과는 반드시 데이터베이스에 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[1, 2, 3]",mjw8523@gmail.com
226,226,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열(Array)은 같은 자료형을 가진 연속된 메모리 공간으로 이루어진 자료구조이다. 가장 기본적이 자료구조로, 구조가 간단하여 데이터를 읽어오는데 걸리는 시간이 가장 빨라서 많은 양의 데이터를 처리할 때 유용하다. 배열을 구성하는 값들을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(Index)라고 한다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
227,227,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션이 신뢰를 가지기 위해 다음과 같은 특성을 가진다.원자성(Atomicity)트랜잭션에 포함된 명령들은 모두 수행되거나, 모두 수행 안되어야 한다. 즉 어느 명령은 실행되고 어느 명령은 실행되지 않으면 안된다.일관성(Consistancy)트랜잭션이 완료된 뒤에는 일관적인 상태에 있어야 한다. 트랜잭션의 영향이 한 방향으로만 전달되어야 한다. 지속성(Durability)트랜잭션의 결과는 반드시 데이터베이스에 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 2, 3]",mjw8523@gmail.com
228,228,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"여러 데이터를 하나의 이름으로 그룹핑해서 관리하는 자료구조(하나의 변수에 여러 데이터)로 반복문과 결합하여 많은 정보를 효율적으로 처리한다. 배열의 인덱스를 이용하여 값을 식별할 수 있으며, 크기가 고정되어있다는 단점이 존재한다.
","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[0],"['랜덤 엑세스', '시간 복잡도', '저장 순서']",[],mjw8523@gmail.com
229,229,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.
일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 3]",mjw8523@gmail.com
230,230,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의됩니다.
배열을 구성하는 각각의 값을 배열 요소 (element)라고 하며, 배열에서의 위치를 가리키는 숫자는 인덱스(index)라고 합니다. 인덱스로 접근할 때 시간 복잡도가 0(1)이라는 장점이 있습니다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[1],mjw8523@gmail.com
231,231,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
영속성(Durability) : 트랜잭션이 성공적으로 완료 되었으면 결과는 영구적으로 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2]",mjw8523@gmail.com
232,232,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,각 배열의 원소들의 데이터 크기는 같다. 또한 연속적으로 메모리에 저장된다는 특징이 있으며 인덱스를 통해 랜덤액세스가 가능하다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",mjw8523@gmail.com
233,233,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.
일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1]","['일관성', '독립성', '지속성', '원자성']","[0, 3]",mjw8523@gmail.com
234,234,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,각 배열의 원소들의 데이터 크기는 같다. 또한 연속적으로 메모리에 저장된다는 특징이 있으며 인덱스를 통해 랜덤액세스가 O(1)의 시간복잡도를 통해 가능하다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
235,235,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
영속성(Durability) : 트랜잭션이 성공적으로 완료 되었으면 결과는 영구적으로 반영되어야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 2]",mjw8523@gmail.com
236,236,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,배열은 인덱스를 통해 랜덤액세스가 O(1)의 시간복잡도를 통해 가능하다. 논리적인 저장순서와 물리적인 저장순서가 동일하다는 특징이 있다.,"['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
237,237,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션은 작업의 안전성과 데이터의 무결성을 유지시키기 위해 다음의 4가지 성질을 가지고 있습니다.

Atomicity(원자성)
트랜잭션의 수행결과는 데이터베이스에 전부 반영되거나, 전부 반영되지 않아야 합니다.(Nothing or All)
Consistency(일관성)
트랜잭션 수행 후 데이터 모델의 모든 제약조건을 만족하지 않아도 됩니다.
Isolation(고립성)
Durability(지속성)
트랜잭션의 성공결과는 장애 발생 후에도 변함없이 보관되어야 합니다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
238,238,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"데이터를 순차적으로 저장하며, 물리적으로도 순차적으로 저장되어 있다. 인덱스를 통해 원하는 데이터를 접근할 수 있으며, O(1)에 랜덤 액세스가 가능하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
239,239,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션은 작업의 안전성과 데이터의 무결성을 유지시키기 위해 다음의 4가지 성질을 가지고 있습니다.

Atomicity(원자성)
Consistency(일관성)
트랜잭션 수행 후 데이터 모델의 모든 제약조건을 만족해야 합니다.
Isolation(고립성)
트랜잭션 수행 시 다른 트랜잭션이 영향을 미치지 않아야 합니다.
Durability(지속성)","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[2],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
240,240,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"데이터를 순차적으로 저장하며, 물리적으로도 순차적으로 저장되어 있다. 인덱스를 통해 원하는 데이터를 접근할 수 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
241,241,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션에는 4가지의 특징(원자성 Atomicity, 일관성 Consitency, 독립성 Isolation,
 영속성 Durability)이 있습니다. 4가지의 특징의 앞 글 자만 따서 ACID라고도 불립니다.
원자성은 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장합니다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[0],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
242,242,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"인덱스를 통해 원하는 데이터를 접근할 수 있으며, O(1)에 랜덤 액세스가 가능하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1]",mjw8523@gmail.com
243,243,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"트랜잭션은 3가지의 특징인 원자성 Atomicity, 일관성 Consitency, 독립성 Isolation이 있습니다.

원자성(Atomicity)
트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장한다.

독립성 ( Isolation )
트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 2]","['일관성', '독립성', '지속성', '원자성']","[1, 3]",mjw8523@gmail.com
244,244,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 메모리 상에 데이터가 연속적으로 저장되고, 순차적으로 저장된 데이터를 참조하는 데에는 Index가 사용된다. 원소에 접근할 때는 O(1)의 시간 복잡도를 갖는다.
","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",mjw8523@gmail.com
245,245,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity)
트랜잭션 안의 SQL 명령문을 모두 성공적으로 실행하여 완료하거나 아니면 모두 철회하여 무효화해야함을 의미

일관성(Consistency)
데이터베이스가 트랜잭션 실행 전의 일관된 상태에서 실행 후에도 또 다른 일관된 상태로 전환되어야함을 의미

고립성(Isolation)
커밋될 때까지 트랜잭션이 수행한 임시 실행 결과가 다른 트랜잭션에게 공개되지 않아야함을 의미

지속성(Durability)
일단 트랜잭션이 커밋되면 그 실행 결과는 장애가 발생하더라도 최종적으로 저장 장치에 반영되는 것을 보장함을 의미","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
246,246,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 메모리 상에 데이터가 연속적으로 저장되고, 순차적으로 저장된 데이터를 참조하는 데에는 Index가 사용된다. 원소에 접근할 때는 O(N)의 시간 복잡도를 갖는다.
","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",mjw8523@gmail.com
247,247,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"일관성(Consistency)
데이터베이스가 트랜잭션 실행 전의 일관된 상태에서 실행 후에도 또 다른 일관된 상태로 전환되어야함을 의미

고립성(Isolation)
커밋될 때까지 트랜잭션이 수행한 임시 실행 결과가 다른 트랜잭션에게 공개되지 않아야함을 의미

지속성(Durability)
일단 트랜잭션이 커밋되면 그 실행 결과는 장애가 발생하더라도 최종적으로 저장 장치에 반영되는 것을 보장함을 의미","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2]",mjw8523@gmail.com
248,248,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 메모리 상에 데이터가 연속적으로 저장되고, 순차적으로 저장된 데이터를 참조하는 데에는 Index가 사용된다. Index를 통해 랜덤 액세스가 가능하며 캐시 히트 비율이 높다.
","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 2]",mjw8523@gmail.com
249,249,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity)
트랜잭션 안의 SQL 명령문을 모두 성공적으로 실행하여 완료하거나 아니면 모두 철회하여 무효화해야함을 의미

일관성(Consistency)
데이터베이스가 트랜잭션 실행 전의 일관된 상태에서 실행 후에도 또 다른 일관된 상태로 전환되어야함을 의미

지속성(Durability)
일단 트랜잭션이 커밋되면 그 실행 결과는 장애가 발생하더라도 최종적으로 저장 장치에 반영되는 것을 보장함을 의미","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 2, 3]",mjw8523@gmail.com
250,250,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 여러 개의 데이터들을 효율적으로 저장/관리/사용하기위해 사용되는 자료형이다. 각각의 Element들의 위치에 번호를 붙여서 그 위치에 Access하는 구조로 되어있는데, 이 번호를 Index라고 한다. Array의 주요 특징은 메모리상에 데이터들이 연속적으로 저장되어있다는 점이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
251,251,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity)
트랜잭션 안의 SQL 명령문을 모두 성공적으로 실행하여 완료하거나 아니면 모두 철회하여 무효화해야함을 의미

일관성(Consistency)

고립성(Isolation)
커밋될 때까지 트랜잭션이 수행한 임시 실행 결과가 다른 트랜잭션에게 공개되지 않아야함을 의미
","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[0],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 3]",mjw8523@gmail.com
252,252,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 각 Element들의 위치에 번호를 붙여서 그 위치에 Access하는 구조로 되어있는데, 이 번호를 Index라고 한다. 이 Index를 통해 random access가 가능하고, O(1)의 시간이 걸린다. Array의 주요 특징은 메모리상에 데이터들이 연속적으로 저장되어있다는 점이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
253,253,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity)
트랜잭션을 구성하는 작업 전체가 성공하거나, 아니면 전체가 실패하는 것 둘 중 하나만을 보장하는 특징이다.
일관성
트랜잭션 실행 이전의 데이터베이스가 Correct State 였다면, 트랜잭션 실행 이후의 데이터베이스도 Correct State 임을 보장해야하는 특징이다.
지속성(Durability)
성공적으로 완료(Commit)된 트랜잭션은 영원히 반영되어야 하는 특징을 의미한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 2, 3]",mjw8523@gmail.com
254,254,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 각 Element들의 위치에 번호를 붙여서 그 위치에 Access하는 구조로 되어있는데, 이 번호를 Index라고 한다. 이 Index를 통해 random access가 가능하고, O(1)의 시간이 걸린다. Array의 주요 특징은 메모리상에 데이터들이 비연속적으로 저장되어 있다는 것이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
255,255,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity)
트랜잭션을 구성하는 작업 전체가 성공하거나, 아니면 전체가 실패하는 것 둘 중 하나만을 보장하는 특징이다.
일관성
트랜잭션 실행 이전의 데이터베이스가 Correct State 였다면, 트랜잭션 실행 이후의 데이터베이스도 Correct State 임을 보장해야하는 특징이다.
격리성(Isolation)
실행중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없는 특징이다
지속성(Durability)
성공적으로 완료(Commit)된 트랜잭션은 영원히 반영되어야 하는 특징을 의미한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
256,256,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"Array는 각 Element들의 위치에 번호를 붙여서 그 위치에 Access하는 구조로 되어있는데, 이 번호를 Index라고 한다. 이 Index를 통해 random access가 불가능하고, O(N)의 시간이 걸린다. Array의 주요 특징은 메모리상에 데이터들이 연속적으로 저장되어 있다는 것이다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
257,257,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"데이터베이스 트랜잭션들이 안정적으로 수행된다는 것을 보장하기 위한 성질으로, ACID라고 불린다.

원자성, 일관성, 고립성, 독립성이 있다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
258,258,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"인덱스를 가지고있으며 순차적으로 데이터가 삽입 삭제될수있는 형태의 자료구조이다. 인덱스로 특정요소를 빠르게 색인가능하며, 실제메모리상에서 물리적으로 데이터가 순차적으로 저장한다.

","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']",[2],mjw8523@gmail.com
259,259,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"데이터베이스 트랜잭션들이 안정적으로 수행된다는 것을 보장하기 위한 성질으로, ACID라고 불린다.

원자성, 일관성, 고립성이 있다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 3]",mjw8523@gmail.com
260,260,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"인덱스를 가지고있으며 순차적으로 데이터가 삽입 삭제될수있는 형태의 자료구조이다. 인덱스로 특정요소를 O(1)의 시간복잡도로 색인가능하며, 실제메모리상에서 물리적으로 데이터가 순차적으로 저장되지 않는다.

","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",mjw8523@gmail.com
261,261,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"데이터베이스의 트랜잭션이 안전하게 수행되기 위해서는 ACID 조건을 충족해야 한다. ACID란 Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성)의 약자로서, 데이터베이스의 트랜잭션이 안전하게 수행되기 위한 4가지 필수적인 성질을 말한다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
262,262,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"선형 자료구조로 배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있으며, O(1)의 시간복잡도로 배열을 탐색할 수 있다. 물리적인 주소와 논리적인 주소(인덱스)가 일치한다는 특징이 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",mjw8523@gmail.com
263,263,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성, 일관성이 있다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 3]",mjw8523@gmail.com
264,264,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"선형 자료구조로 배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있으며, O(1)의 시간복잡도로 배열을 탐색할 수 있다. 물리적인 주소와 논리적인 주소(인덱스)가 일치하지 않는다는 특징이 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']",[1],"['랜덤 엑세스', '시간 복잡도', '저장 순서']","[1, 2]",mjw8523@gmail.com
265,265,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,Atomicity - 원자성 Consistency - 일관성 lsolation - 독립성 Durability - 지속성,"['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']",[],"['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
266,266,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"선형 자료구조로 배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있으며, 인덱스를 통해 O(1)의 시간복잡도로 배열을 랜덤액세스할 수 있다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1]",mjw8523@gmail.com
267,267,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"원자성(Atomicity): 트랜잭션은 더 이상 분해가 불가능한 최소한의 작업 처리 단위다.
일관성(Consistency): 트랜잭션 실행의 결과는 일관성을 가진다.
격리성(Isolation): 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없다.
영속성(Durability): 트랜잭션이 실행을 성공적으로 완료하면 그 결과는 DB에 영속적으로 저장된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[0, 1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2, 3]",mjw8523@gmail.com
268,268,1,[자료구조 1] Array의 특징을 설명해주세요.,kshired,"배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 자료구조이다.
메모리상에서 연속적으로 저장되어 있는 특징을 갖기때문에, index를 통한 접근이 용이하다.
배열의 크기는 처음 생성할 때 정하며 이후에는 변경할 수 없다. 접근하고자 하는 인덱스를 알고있을 때는 랜덤액세스를 통해 O(1)로 접근가능하다.","['인덱스(index)로 해당 원소(element)에 접근할 수 있다.', 'O(1)의 시간복잡도로 랜덤 액세스가 가능하다.', '논리적 저장 순서와 물리적 저장 순서가 일치한다.']","[0, 1, 2]","['랜덤 엑세스', '시간 복잡도', '저장 순서']","[0, 1, 2]",mjw8523@gmail.com
269,269,3,[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,kshired,"일관성(Consistency): 트랜잭션 실행의 결과는 일관성을 가진다.
격리성(Isolation): 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없다.
영속성(Durability): 트랜잭션이 실행을 성공적으로 완료하면 그 결과는 DB에 영속적으로 저장된다.","['만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.', '트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.', '각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.', '트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.']","[1, 2, 3]","['일관성', '독립성', '지속성', '원자성']","[0, 1, 2]",mjw8523@gmail.com
270,270,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 할당 받은 자원을 이용하는 실행 단위이다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[0],mjw8523@gmail.com
271,271,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 코드의 집합으로 이루어진 프로그램이 실행되는 것이고 스레드는 실행되는 프로그램의 작업 단위를 뜻하며 여러개의 스레드가 생겨날 수 있다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[0],mjw8523@gmail.com
272,272,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 경량화된 프로세스라고 볼 수 있다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[2],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[0],mjw8523@gmail.com
273,273,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 프로그램의 단위이고 스레드는 작업의 단위이며 프로세스를 할당할 때 메모리의 스택, 힙, 코드, 데이터 영역을 전부 할당하지만 스레드는 프로세스의 힙, 데이터, 코드영역을 공유하기 때문에 각 스레드에 스택만 따로 할당된다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 2, 3, 4]",mjw8523@gmail.com
274,274,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 프로그램의 단위이고 스레드는 작업의 단위이며 프로세스를 할당할 때 메모리의 스택, 힙, 코드, 데이터 영역을 전부 할당하지만 스레드는 프로세스의 자원을 공유하기 때문에 스택영역만 할당된다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 2, 3, 4]",mjw8523@gmail.com
275,275,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 단순하게 말하면 일을 처리하는 일련의 과정을 말합니다. 그리고 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름입니다. 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행시킬 수 있는 것을 말합니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[4],mjw8523@gmail.com
276,276,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 프로그램 단위로 실행되며 모든 영역을 할당받습니다. 하지만 스레드는 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유합니다. 기본적으로 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성되며 이는 메인스레드라고 불립니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[4],mjw8523@gmail.com
277,277,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이고 스레드는 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유한다. (힙, 데이터, 코드영역)","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 4]",mjw8523@gmail.com
278,278,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스란 메모리에 올라와 실행되고 있는 프로그램의 인스턴트를 말합니다. 그리고 스레드란 한 프로세스 내에서 동작되는 작업 단위로 분류합니다,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 3]",mjw8523@gmail.com
279,279,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 컴퓨터에서 연속적으로 실행되고 있는 프로그램이고 스레드는 프로세스 내에서 실행되는 여러 흐름의 단위입니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
280,280,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 메모리에 로드되어 실행되고 있는 프로그램의 인스턴스 입니다. 그리고 스레드는 프로세스 내에서 실행되는 여러 흐름 단위 입니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[3],mjw8523@gmail.com
281,281,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,운영체제로부터 시스템 자원을 할당받고 운영체제가 관리하는 단위가 프로세스 이고 프로세스가 할당받은 자원을 이용하는 실행 단위가 스레드입니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
282,282,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세서(처리기, CPU)에 의해 처리되는 프로그램이 프로세스이고 스레드는 프로세스의 특정 실행 단위이다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[0],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
283,283,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 운영체제로부터 자원을 할당받아 실행, 스레드는 프로세스로부터 자원을 할당받아 실행","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
284,284,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"하나의 프로세스안에 여러 스레드 생성이 가능하며, 각 스레드는 개별 스택을 가지고 프로세스의 전역 메모리 공간을 공유하며 프로그램을 실행합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[3, 4]",mjw8523@gmail.com
285,285,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 독립된 메모리 영역을 할당받는다. Stack, Code, Data, Heap 영역을 전부 할당 받는다. 그리고 각 프로세스는 다른 프로세스의 할당된 메모리공간에 접근할 수 없으며, 접근이 필요한경우 IPC를 사용하게 된다.
스레드는 프로세스 내에서 각각 별도의 레지스터와 Stack을 할당 받으며. Code, Data, Heap영역을 공유한다. 따라서 IPC와 같은 별도의 기법없이도 쓰레드간 데이터를 손쉽게 주고 받을 수 있게된다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
286,286,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 독립된 메모리 영역을 할당받는다. Stack, Code, Data, Heap 영역을 전부 할당 받는다. 스레드는 프로세스 내에서 각각 별도의 레지스터와 Stack을 할당 받으며. Code, Data, Heap영역을 공유한다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
287,287,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 자원을 공유하지 않지만 스레드는 자원을 공유한다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[4],mjw8523@gmail.com
288,288,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 메모리에 적재되고 CPU자원을 할당받아 프로그램이 실행되고 있는 상태이고 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[3],mjw8523@gmail.com
289,289,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 메모리에 적재되고 CPU자원을 할당받아 프로그램이 실행되고 있는 상태이다. 그리고 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.
프로세스는 할당받을 때 모든 영역을 할당받지만 스레드는 프로세스 내에 있기 때문에 공유된 자원을 사용하고 스택만 독립적으로 할당받아 사용하게 된다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
290,290,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스에 비해 쓰레드의 컨텍스트 스위칭 비용이 더 적다. 왜냐하면 스레드끼리는 프로세스의 자원을 공유해서 사용하기 때문에 덜 교체를 해도 돼서 비용이 덜하다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[1, 4]",mjw8523@gmail.com
291,291,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 개별 메모리를 차지하고 스레드는 공유된 자원으로 메모리를 효율적이게 사용한다. 하지만 스레드는 공유 자원 문제를 관리해야한다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[3, 4]",mjw8523@gmail.com
292,292,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 쓰레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[0],mjw8523@gmail.com
293,293,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 자기 고유의 자원을 가지고 있다 (Code, Data, File), 스레드는 각자의 흐름을 위해 사용된다 (Register, Stack)","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[2],mjw8523@gmail.com
294,294,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 실행될 때 운영체제로부터 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받습니다. 기본적으로 하나의 프로세스가 생성되면 하나의 쓰레드가 같이 생성됩니다. 쓰레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내에서 각각 Stack만 따로 할당 받고 Code, Data, Heap 영역은 공유합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
295,295,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"쓰레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 쓰레드끼리 공유하면서 실행됩니다. 따라서 한 쓰레드가 프로세스 자원을 변경하면 다른 이웃 쓰레드도 그 변경 결과를 즉시 볼 수 있습니다. 하지만 프로세스는 별도의 주소 공간에서 실행되며 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간 통신 (IPC)을 사용해야 합니다. 예를 들어 파이프, 파일, 소켓 등이 이에 해당합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[4],mjw8523@gmail.com
296,296,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램이며 메모리에 올라와 실행되고 있는 프로그램의 인스턴스입니다. 쓰레든는 프로세스 내에서 실행되는 여러 흐름의 단위이며 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[3],mjw8523@gmail.com
297,297,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하고 스레드는 다른 스레드와 공간과 자원을 공유하면서 사용한다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[2],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[4],mjw8523@gmail.com
298,298,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다. 프로세스는 최소 하나의 스레드를 보유하고 있으며 각각 별도의 주소공간을 독립적으로 할당 받는다. (code, heap, stack) 스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
299,299,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 생성할 때 많은 시간이 소요되며 컨텍스트 스위칭이 비효율적이고 프로세스간에 통신이 어렵다. 스레드는 생성 및 소멸이 프로세스에 비해 가볍고 컨텍스트 스위칭이 빠르다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[1],mjw8523@gmail.com
300,300,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 운영체제로부터 자원을 할당받은 작업의 단위를 말하며 메모리에 올라와 실행되고 있는 프로그램의 독립적인 인스턴스이다. 동적인 개념으로는 실행되는 프로그램을 의미한다.
스레드는 프로세스 내에서 실행되는 여러 흐름의 단위이다. 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.
","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 3]",mjw8523@gmail.com
301,301,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 각각 독립된 메모리 영역인 data, code, stack heap 구조를 모두 할당받는다.
하지만 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 code, data, heap 영역은 공유한다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[1, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
302,302,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"각각의 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근하려면 IPC(inter-process communication)을 사용해야 한다.
스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스내에 스레드끼리 공유하기 때문에 스택영역을 제외하고는 서로의 자원에 접근할 수 있다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
303,303,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스와 스레드는 본질적으로 연관되어 있습니다. 프로세스는 프로그램의 실행이지만 스레드는 프로세스의 환경에 의해 구동되는 프로그램의 실행입니다. 프로세스와 스레드를 구별하는 또 다른 주요 점은 프로세스가 서로 고립되어있는 반면 스레드는 서로 메모리 또는 자원을 공유한다는 점입니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[3, 4]",mjw8523@gmail.com
304,304,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 메모리에 올라와 실행중인 프로그램이며 스레드는 그 프로세스가 해야 할 작업을 나눠서 하는 그 일부입니다.
프로세스는 다른 프로세스와 완전히 격리 되었기 때문에 메모리를 공유하지 않습니다.
하지만 스레드는 같은 프로세스 안에 있다는 가정하에 메모리를 서로 공유합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[3, 4]",mjw8523@gmail.com
305,305,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 할당할 때 스택, 힙, 코드, 데이터 영역을 전부 할당해주어야 하기 때문에 생성에 드는 시간이 오래 걸립니다. 하지만 스레드는 프로세스의 힙, 코드, 데이터 영역을 공유하기 때문에 스택영역과 레지스터만 할당해줘도 돼서 빠릅니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[1],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 4]",mjw8523@gmail.com
306,306,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,Context switching시에 프로세스가 더 오래 걸린다. 왜냐하면 프로세스는 모든 메모리 영역을 전부 바꿔줘야하지만 스레드는 스택영역만 비워주면 되기 때문입니다. 또한 프로세스 Context switching시에는 캐시메모리를 함께 비워주어야 하지 때문에 더 느립니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[1, 2, 3]",mjw8523@gmail.com
307,307,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 프로그램을 실행하고 프로그램에서 지정된 관련 작업을 수행하거나 프로그램이 실행되는 실행 단위입니다. 스레드는 작업을 수행하기 위해 프로세스 리소스를 사용하는 프로그램 실행입니다. ,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 2]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
308,308,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로그램의 모든 스레드는 프로세스 내에 논리적으로 포함됩니다. 프로세스는 가중치가 있지만 스레드는 가중치가 있습니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[3],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
309,309,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,프로세스는 격리 된 실행 단위이며 스레드는 격리되어 있지 않고 메모리를 공유합니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[3, 4]",mjw8523@gmail.com
310,310,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,스레드는 개별 존재를 가질 수 없습니다. 그것은 프로세스에 첨부됩니다. 반면에 프로세스는 개별적으로 존재할 수 있습니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[3],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[],mjw8523@gmail.com
311,311,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,스레드가 만료될 때 모든 스레드가 자체 스택을 가지고 있으므로 연관된 스택을 복구 할 수 있습니다. 반대로 프로세스가 종료되면 모든 스레드가 프로세스를 포함하여 종료됩니다.,"['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']",[2],mjw8523@gmail.com
312,312,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 '컴퓨터에서 연속적으로 실행되고 있는 프로그램'입니다. 메모리 상에 올려진 프로그램의 한 개체라고 보면 됩니다. 운영체제(OS)로부터 자원을 할당받은 작업의 단위입니다.
스레드는 '프로세스 내에서 실행되는 작업 흐름의 단위'입니다. 한 프로세스 내에서 Stack만 따로 할당을 받고 Code, Data, Heap영역은 공유합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[0, 2, 3, 4]",mjw8523@gmail.com
313,313,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 하나의 프로그램이 OS에게 메모리를 할당받아 실행되고 있는 것이며, 스레드는 그 프로세스 내에서 실행되는 작업의 흐름 단위입니다. 프로세스는 OS에게 Stack, heap, data 등을 메모리 영역으로써 할당받고, 스레드는 해당 프로세스 내에서 Stack을 제외한 자원을 다른 스레드와 공유합니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']","[0, 1, 2, 3]","['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[2, 3, 4]",mjw8523@gmail.com
314,314,8,[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,jack,"프로세스는 프로세스끼리 작업을 바꾸는 Context Switching 과정에서 작업이 더 무거워집니다. 왜냐하면 프로세스끼리는 공유되는 메모리가 없기 때문에 프로세스가 바뀌는 과정에서 데이터 리셋, cache 정보 불러오기 과정을 거쳐야하므로 많이 무겁고 느려집니다.","['스레드는 할당받은 자원을 이용하는 실행의 단위이다.', '스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.', '프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에 존재한다.']",[],"['작업 단위', 'context switching', 'stack', '메모리', '영역 공유']","[1, 3]",mjw8523@gmail.com
315,315,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를 거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
316,316,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높으면 인덱스 설정에 좋은 컬럼이다.  선택도가 낮으면 인덱스 설정에 좋은 컬럼이다. 조회 활용도가 높으면 인덱스 설정에 좋은 컬럼이다. 수정 빈도가 낮으면 인덱스 설정에 좋은 컬럼이다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1, 2, 3]",mjw8523@gmail.com
317,317,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"전체 행에 대한 특정 컬럼의 데이터 중복 수치에 대한 정보를 기수성(Cardinality)라고 합니다. 중복되는 횟수가 높으면 기수성 값이 낮고, 중복되는 횟수가 낮으면 기수성 값이 높다고 표현합니다.선택도는 기수성으로부터 계산할 수 있습니다. 선택도가 수식을 보면 알 수 있듯이 기수성 값이 높을수록 선택도 또한 같이 높아집니다. 선택도가 ‘1’ 이라는 의미는 모든 값이 유일(unique)하다는 의미입니다. 높은 선택도를 가지는 컬럼을 인덱스로 설정하는 경우 조회 성능이 향상됩니다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 3]",mjw8523@gmail.com
318,318,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"접근 경로 표를 기준으로 어떤 컬럼이 자주 사용되는 지를 판단하고 해당 컬럼의 분포도를 조사해야 한다.

분포도란 Cardinality라고 하며 한 컬럼에 얼마나 다양한 값이 어떻게 분포되어 있는 지를 나타낸다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
319,319,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋다. 가장 최선은 PK로 인덱스를 거는 것이라고 할 수 있다. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고, 반대로 모든 값이 같은 컬럼의 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것이다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
320,320,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"조건절에 자주 등장하는 컬럼, LIKE 검색보다는 = 으로 검색하는 컬럼, ORDER BY 절에서 자주 사용되는 컬럼, JOIN으로 자주 사용되는 컬럼","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[1],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
321,321,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[3],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[1],mjw8523@gmail.com
322,322,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"1개의 컬럼만 인덱스를 걸어야 한다면, 해당 컬럼은 카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다는 점입니다.

카디널리티(Cardinality)란 해당 컬럼의 중복된 수치를 나타냅니다.
예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다.
반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.

인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다.
만약 성별을 인덱스로 잡는다면, 남/녀 중 하나를 선택하기 때문에 인덱스를 통해 50%밖에 걸러내지 못합니다.
하지만 주민등록번호나 계좌번호 같은 경우엔 인덱스를 통해 데이터의 대부분을 걸러내기 때문에 빠르게 검색이 가능합니다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[0],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
323,323,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,조회시 자주 사용하는 컬럼에 고유한 값 위주로 카디널리티가 높은 곳에 적용해야 한다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2]",mjw8523@gmail.com
324,324,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"조건절에 항상 사용되거나, 적어도 자주 사용되는 컬럼들을 선정하고  '='조건으로 자주 조회되는 컬럼을 앞쪽에 두어야 한다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[1],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
325,325,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"규모가 작지 않은 테이블에서 INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼에 적용해야 합니다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[3],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[1],mjw8523@gmail.com
326,326,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼, 데이터의 중복도가 낮은 컬럼","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[],mjw8523@gmail.com
327,327,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,데이터의 중복도가 낮아서 분포도가 높은 컬럼에 대해 인덱스를 사용해야 한다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[],mjw8523@gmail.com
328,328,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"데이터의 중복도가 낮은 컬럼, 즉 카디널리티가 높은 컬럼이 적합하다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
329,329,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 Index를 걸어주어야 합니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[1],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
330,330,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,일반적으로 카디널리티가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다. 카디널리티란 특정 데이터 집합의 유니크한 값의 개수를 의미합니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[0],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
331,331,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,데이터의 중복도가 낮은 칼럼을 사용하는 것이 유리하다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[],mjw8523@gmail.com
332,332,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"인덱스 컬럼의 분포도가 10~15% 이내인 컬럼이며 부분처리를 목적으로 하는 경우, 입출력 장표 등에서 조회 및 출력조건으로 사용되는 경우, 수정이 빈번하지 않은 경우에 인덱스로 사용해야 한다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[1, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[1, 2]",mjw8523@gmail.com
333,333,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"인덱스는 테이블마다 하나 혹은 여러 개의 컬럼에 대해 설정할 수 있다. 단일 인덱스를 여러 개 생성할 수도 있고, 여러 컬럼을 묶어 복합 인덱스를 설정할 수도 있다.

그러나 무조건 인덱스를 많이 설정하는 것이 검색 속도를 향상시키는 데 도움을 주지 않는다. 인덱스는 데이터베이스의 저장 공간을 사용해 테이블 형태로 저장되므로 개수와 저장 공간은 비례한다.

따라서, 조회 시 자주 사용하고 고유한 값 위주로 인덱스를 설정하는 것이 성능에 도움이 된다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[1],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
334,334,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"테이블의 행이 적은 테이블이나 where 로 조건을 줘서 검색할때 10~15% 의 결과보다 높게 리턴될때나 테이블이 자주 입력,수정,삭제 되는 테이블에는 인덱스를 생성,사용하지 않는게 맞다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[3],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[1, 2]",mjw8523@gmail.com
335,335,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,인덱스는 카디널리티가 높은 컬럼에 설정하는 것이 유리합니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[0],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
336,336,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"데이터베이스 인덱스를 설정할때는 카디널리티가 높은 것, 선택도가 낮은 것에 설정해야 합니다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 3]",mjw8523@gmail.com
337,337,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 선택도가 낮은 컬럼에 설정하는 것이 좋다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 3]",mjw8523@gmail.com
338,338,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,중복도가 낮은 컬럼이 적합하다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[],mjw8523@gmail.com
339,339,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,중복도와 선택도가 낮은 컬럼이 유리하다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[3],mjw8523@gmail.com
340,340,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"카디널리티가 높고, 선택도가 낮고 자주 조회되는 컬럼이라면 인덱스 설정에 유리하다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 3]",mjw8523@gmail.com
341,341,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"카디널리티, 선택도, 조회 빈도 등을 고려해야 하는데 이때 카디널리티가 높고 선택도가 낮고 조회빈도수가 높을 수록 적합하다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2, 3]",mjw8523@gmail.com
342,342,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,수정이 자주 되지 않고 조회는 자주된다면 인덱스에 적합한 컬럼이다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[1, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[1, 2]",mjw8523@gmail.com
343,343,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높으면서 자주 조회된다면 인덱스로 적합하다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2]",mjw8523@gmail.com
344,344,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 수정빈도는 낮다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1]",mjw8523@gmail.com
345,345,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,중복도는 낮고 조회 활용도는 높다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[2],mjw8523@gmail.com
346,346,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"높은 카디널리티와 낮은 선택도, 높은 조회활용도와 낮은 수정빈도를 갖는다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1, 2, 3]",mjw8523@gmail.com
347,347,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티와 조회활용도는 높고 선택도와 수정빈도는 낮다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1, 2, 3]",mjw8523@gmail.com
348,348,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[0],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
349,349,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,조인에 자주 사용되고 중복도가 낮은 컬럼을 인덱스로 사용하는 것이 좋다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[],mjw8523@gmail.com
350,350,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"선택도가 낮은, 즉 한 컬럼이 갖고있는 값으로 최대한 적은 행이 찾아지는 컬림이 적합하다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[2],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[3],mjw8523@gmail.com
351,351,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높아 값의 중복도가 낮다는 특징을 가진다. 뿐만 아니라 자주 조회되고 덜 수정된다는 특징 또한 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1, 2]",mjw8523@gmail.com
352,352,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,선택도가 낮다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[2],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[3],mjw8523@gmail.com
353,353,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높아 불필요한 데이터를 인덱스로 많이 걸러낼 수 있다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[0],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[0],mjw8523@gmail.com
354,354,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 선택도가 낮아 빠르게 값을 찾을 수 있는 컬럼이다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 3]",mjw8523@gmail.com
355,355,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 선택도가 낮으며 자주 조회된다는 특징을 가진다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2, 3]",mjw8523@gmail.com
356,356,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,인덱스로 사용하기에 가장 적합한 컬럼은 중복도와 선택도가 낮은 컬럼이다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']",[3],mjw8523@gmail.com
357,357,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,"카디널리티, 선택도, 조회 빈도 등을 고려하여 데이터를 빠르게 조회할 수 있는 컬럼에 설정한다.","['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']",[],"['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2, 3]",mjw8523@gmail.com
358,358,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 선택도가 낮으며 자주 조회된다는 특징을 가집니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 2, 3]",mjw8523@gmail.com
359,359,6,[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,big jo,카디널리티가 높고 선택도가 낮으며 자주 조회되고 수정 빈도가 낮은 컬럼입니다.,"['카디널리티가 상대적으로 높은 컬럼', '조회 빈도가 높은 컬럼', '선택도가 상대적으로 낮은 컬럼', '수정 빈도가 낮은 컬럼']","[0, 1, 2, 3]","['카디널리티', '수정 빈도', '조회 빈도', '선택도']","[0, 1, 2, 3]",mjw8523@gmail.com
360,360,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조. 즉, 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.
","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
361,361,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"후입선출(Last In First Out, LIFO) 의 형태를 가진 자료구조로, 데이터의 개수가 스택의 크기를 초과하면 overflow가 일어나고, 아무것도 없을 때 pop을 하거나 데이터에 접근시 underflow가 일어나기 때문에 구현시 예외처리가 필수적이다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 3]",mjw8523@gmail.com
362,362,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"LIFO 구조로, 가장 상위에 위치하는 자료는 최근에 들어온 자료입니다. 자료를 삭제하는 연산은 pop 연산으로 가장 최근에 들어온 자료가 삭제 됩니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 3]",mjw8523@gmail.com
363,363,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"삽입, 삭제 연산이 한 방향에서 이루어지는 선형 자료구조로, 한 방향에서 삽입과 삭제가 이루어지기 때문에 나중에 삽입된 데이터가 먼저 삭제되는 후입선출(LIFO, Last In First Out) 구조를 가진다. 스택에 데이터가 삽입될 위치를 Top이라고 한다. 비어있는 스택에서 원소를 추출하려고 할 때 stack underflow가 발생하고, 스택이 넘치는 경우를 stack overflow라고 한다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
364,364,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있고,
top으로 정한 곳을 통해서만 접근할 수 있다.
top에는 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며,
삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.
스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다. 이러한 스택의 구조를 후입선출(LIFO, Last-In-First-Out) 구조이라고 한다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
365,365,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 위의 그림과 같이 아래에서 위로 쌓이는 형식이며 가장 최근에 들어온 자료를 top이라고 부릅니다. 가장 위쪽(최신)의 데이터부터 꺼낼 수 있으며 이러한 스택의 구조를 후입선출(LIFO, Last In First Out)의 구조라고 합니다. 즉, 스택의 경우 자료의 삽입과 삭제는 한 곳(top)에서만 이루어지게 됩니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
366,366,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,가장 최근에 보관한 자료를 먼저 꺼내는 LIFO(Last In First Out)방식의 자료 구조이다. 리스트의 한쪽으로 삽입과 삭제 연산을 수행한다.,"['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
367,367,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,선형 자료구조로 LIFO(Last-In-First-Out)라는 특징을 가지고 있다. push와 pop은 오직 모두 stack의 top인 구조의 끝에서 동작한다.,"['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
368,368,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고,
top으로 정한 곳을 통해서만 접근할 수 있다.
가장 위에 있는 자료(top)는 가장 최근에 들어온 자료를 가리키고 있으며,
삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.
스택에서 자료를 삭제할 때도 top을 통해서만 가능하다.
스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다.
 
따라서 스택은 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다는 구조적 특징을 갖게 된다.
이러한 스택 구조를 후입선출(LIFO, Last-In-First-Out) 구조라 한다.
","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
369,369,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택(Stack)은 LIFO(Last-In-First-Out, 후입선출)의 특징을 가진 자료구조이다. LIFO란, 가장 먼저들어온 것이 가장 늦게나가는 방식이다. 위와 같이, 1,2,3순서대로 들어갔지만, 나올때는 3,2,1순서로 나오는 것을 LIFO방식이라고하고, 스택은 이러한 LIFO방식을 사용하는 자료구조이다. 즉, 스택에 가장 나중에 들어온 자료가 가장 먼저 삭제된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
370,370,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"그릇 더미들을 쌓을 때에는 아래쪽에서부터 하나씩 쌓아올리고, 해당 그릇 더미들에거 하나의 그릇만 꺼내려고 한다면 가장 위쪽에 있는 거 부터 차례로 꺼낼 수 있을 것입니다. 이러한 맥락에서 스택 자료구조는 후입선출(Last-In-Fist-Out) 의 특징을 가지고 있습니다. 후입선출은 말 그대로 가장 나중에 들어간 것이 가장 먼저 나간다는 의미입니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
371,371,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 자료형의 값을 하나의 방향으로만 쌓을 수 있고, top으로 정한 곳을 통해서만 접근할 수 있다. 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며,  삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.  스택은 시간 순서에 따라 자료가 쌓여서 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다는 구조적 특징을 가지게 된다. 이러한 스택의 구조를 후입선출(LIFO, Last-In-First-Out)구조라고 한다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
372,372,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택이란 가장 마지막에 넣은 자료가 가장 먼저 나오는 특징(LIFO: last in first out)을 가진 자료구조이다. 스택은 탑(top)이라 하는 한쪽 끝에서 모든 삽입(push)과 삭제(pop)가 이루어진다. 쌓아 올린 동전을 생각하면 이해가 쉽다. 무너지지 않은 채, 동전을 쌓거나 내리려면 제일 윗 부분에서 작업을 해야 한다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
373,373,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"자료구조(Data Structure)의 한 종류로 후입선출(LIFO : List in First out)구조를 가지고 있다.
따라서 가장 먼저 들어간 데이터가 가장 끝부분에 위치하게 되는 구조이다.
이러한 특징으로 데이터 저장과 같은 기능에는 적합하나, 실시간 처리를 요구하는 구조에서는 부적합한 자료구조이다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[2, 3]",mjw8523@gmail.com
374,374,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"모든 원소의 삽입과 삭제가 top이라는 자료구조의 한 쪽 끝에서만 수행되는 제한된 리스트 구조이다. 후입 선출 (Last-In-First-Out, LIFO) 방식
으로, 가장 마지막에 입력된 자료가 가장 먼저 출력된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
375,375,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"데이터를 제한적으로 접근할 수 있는 구조이다.
가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조. 즉, 한쪽 끝에서만 자료를 넣거나 뺼 수 있으며 앞선 시간에 살펴본 Queue 와는 반대로 LIFO (Last In First Out) 정책을 사용합니다.
대표적으로 재귀 함수에서 사용 되는 구조 입니다.
 ","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
376,376,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택의 데이터는 스택의 끝에만 삽입, 삭제, 조회가 가능하다. 스택 연산을 묘사하는 데 사용되는 두문자는 LIFO(last in, first out)이다. 스택은 입력 받은 순서와 반대로 데이터를 처리해야 할 때(LIFO) 항상 이상적이다. 워드 프로세서의 ""되돌리기"" 함수나 네트워크 애플리케이션에 쓰이는 함수 호출 등에서 스택이 유용할 것이다. ","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
377,377,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택(Stack)은 쌓다, 쌓이다, 포개지다 와 같은 뜻을 가지고 있다. Stack은 직역 그대로, 데이터(data)를 순서대로 쌓는 자료구조이다.
 입력과 출력이 하나의 방향으로 이루어져 접근이 제한적이다.
이러한 Stack 자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out)이라고 부르기도 한다","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
378,378,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"Stack은 사전적 의미로 쌓다, 포개다, 채우다를 의미합니다. 자료구조 개념의 하나인 Stack은 바로 쌓아 올리는 개념입니다. 보통 Stack의 특징이라고 하면 후입 선출의 또는 LIFO의 개념이라고 말합니다.

후입 선출, List In First Out(LIFO)은 결국 어떠한 일이 계속 쌓이면 마지막에 있는 일부터 처리를 하는 개념입니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']",[3],mjw8523@gmail.com
379,379,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택(Stack)이란 자료구조는 선입후출(First In, Last Out: FILO), 후입선출(Last In, First Out: LIFO)의 구조를 가지고 있습니다. 스택의 특징으로는, 한 방향 끝에서만 데이터의 삽입과 제거가 이루어진다는 것입니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
380,380,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조로,  가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다. 주로 DFS에 사용되며, 삽입과 삭제 그리고 조회의 시간복잡도가 O(1)이라는 특징이 있다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
381,381,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조로,  가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.  삽입과 삭제 그리고 조회의 시간복잡도가 O(1)이라는 특징이 있다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
382,382,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조로, 주로 DFS에 사용되며, 삽입과 삭제 그리고 조회의 시간복잡도가 O(1)이라는 특징이 있다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
383,383,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"
","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']",[],mjw8523@gmail.com
384,384,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 말 그대로 스택처럼 쌓아올리는 형태의 자료구조를 뜻합니다. 기본적으로 현재 스택의 위치를 가리키는 top 의 값을 이용하여 스택을 쌓거나 값을 출력합니다. 삽입과 삭제가 top에서만 이루어지며, DFS에서 사용됩니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[1],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2]",mjw8523@gmail.com
385,385,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,스택은 말 그대로 스택처럼 쌓아올리는 형태의 자료구조를 뜻합니다. 기본적으로 현재 스택의 위치를 가리키는 top 의 값을 이용하여 스택을 쌓거나 값을 출력합니다. DFS에서 사용됩니다.,"['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[1],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2]",mjw8523@gmail.com
386,386,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택(Stack)

먼저 들어 온 데이터가 나중에 나가는 형식(선입후출)의 자료구조이다.
선입후출(First In Last Out) 또는 후입선출(Last In First Out)구조라고 한다.
입구와 출구가 동일한 형태.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
387,387,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,스택은 데이터가 들어오는 입구와 나가는 출구가 같다. 즉 top이라고 불리는 최상단에서 LIFO의 특징을 통해 삽입과 삭제가 이루어진다.,"['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[1],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
388,388,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한 쪽으로만 들어가기 때문에 처음 들어간 것은 밑에 깔려서 나중에 나올 수 밖에 없다. (First In Last Out=FILO)

이로인해 삽입, 삭제, 조회시 O(1)의 시간복잡도가 소요된다.
","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
389,389,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"가장 먼저 들어온게 가장 먼저나가는 구조로, 배열 혹은 연결리스트로 구현이 가능한 자료구조. 삽입 삭제가 O(1)에 가능하다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[2],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2]",mjw8523@gmail.com
390,390,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"가장 나중에 삽입된 것이 가장 먼저나가는 구조로 LIFO라 불리며, 배열 혹은 연결리스트로 구현이 가능한 자료구조. 삽입 삭제가 O(1)에 가능하다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
391,391,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 top 이라고 하는 한쪽 위치에서 모든 삽입(push)과 삭제(pop)가 일어나는 순서 리스트 입니다.
후입선출(Last In First Out : LIFO) 의 특징을 가지고 있습니다. O(1)에 삽입과 삭제가 가능하다는 특징을 가지고 있습니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
392,392,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한쪽 끝에서만 데이터를 넣고 뺄 수 있기 때문에 LIFO(Last-In, First-Out), 즉 후입선출 형식을 가진 자료구조이다. 후위표기법과 DFS 등에서 사용된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
393,393,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,스택은 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 제한적으로 접근할 수 있는 후입선출(Last-In-First-Out) 형태의 선형 자료구조이다. 스택의 삽입이나 삭제시 맨 위의 데이터를 삭제하기 때문에 시간복잡도는 늘 O(N) 이다. 대표적으로 DFS에서 사용된다는 특징이 있다.,"['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
394,394,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 리스트의 한쪽 끝으로는 자료의 삽입, 한쪽은 자료의 삭제가 이루어지는 자료구조이다.
가장 최근에 들어온 자료가 가장 먼저 나가게 되는 LIFO(Last-In First-Out) 형태를 띱니다!
스택의 입출력은 맨 위에서만 일어나기 때문에 스택의 중간에서는 데이터를 삭제하는 것이 불가능 합니다!
","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
395,395,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 top 이라고 하는 한쪽 위치에서 모든 삽입(push)과 삭제(pop)가 일어나는 순서 리스트 입니다.
후입선출(Last In First Out : LIFO) 의 특징을 가지고 있습니다. O(N)에 삽입과 삭제가 가능하다는 특징을 가지고 있습니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
396,396,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 데이터를 관리하는 대표적인 방법으로, LIFO라는 특수한 순서를 따르는 리스트이다.  마지막으로 추가된 데이터가 제일 먼저 삭제된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
397,397,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 후입선출(LIFO : Last in First Out)의 개념으로 만들어진 자료구조로,
 큐(Queue)와 쌍을 이뤄서 설명하는 경우가 많습니다. 삽입과 삭제가 한 곳에서 이루어지며 O(1)의 시간복잡도가 걸립니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
398,398,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 제한적으로 접근할 수 있는 후입선출(Last-In-First-Out) 형태의 선형 자료구조이다. 스택의 삽입이나 삭제시 맨 위의 데이터를 삭제하기 때문에 시간복잡도는 늘 O(1) 이다. 대표적으로 DFS에서 사용된다는 특징이 있다.

","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
399,399,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 제한적으로 접근할 수 있는 후입선출(Last-In-First-Out) 형태의 선형 자료구조이다. 스택의 삽입이나 삭제시 맨 위의 데이터를 삭제하기 때문에 시간복잡도는 늘 O(1) 이다. 대표적으로 BFS에서 사용된다는 특징이 있다.

","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
400,400,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"Stack 이라는 자료구조는 메모리에서도 쓰이고 실생활에서도 볼 수 있는 자료구조 입니다. (수식계산, 수식괄호검사, 웹브라우저의 뒤로/앞으로) LIFO(후입 선출)의 특징을 가지고 있는 것을 다들 알고 있을 것입니다. ","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']",[0],"['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']",[3],mjw8523@gmail.com
401,401,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired," Last In First Out(LIFO) 구조로 가장 나중에 들어간 원소가 가장 먼저 나오게 된다. 삽입과 삭제가 top에서 이루어지며, O(1)에 삽입과 삭제가 가능하다","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 2]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 1, 2, 3]",mjw8523@gmail.com
402,402,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한쪽으로만 데이터를 넣고 뺄 수 있는 형태의 데이터 구조로, 후입 선출(Last In First Out, LIFO)이라는 특성을 지니고 있다. 스택 자료구조는 재귀 알고리즘에서 널리 사용하기도 하고, BFS에서 자주 사용된다.


차곡차곡 쌓여 있는 형태의 데이터 구조라고 보면 된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']",[3],mjw8523@gmail.com
403,403,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 top 이라고 하는 한쪽 위치에서 모든 삽입(push)과 삭제(pop)가 일어나는 순서 리스트 입니다.
선입선출(First In First Out : FIFO) 의 특징을 가지고 있습니다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
404,404,0,[자료구조 2] Stack의 특징을 설명해주세요.,kshired,"스택은 한쪽으로만 데이터를 넣고 뺄 수 있는 형태의 데이터 구조로, 후입 선출(Last In First Out, LIFO)이라는 특성을 지니고 있다. 스택 자료구조는 재귀 알고리즘에서 널리 사용하기도 하고, DFS에서 자주 사용된다.","['마지막으로 들어온 데이터가 처음으로 나간다.', '자료의 삽입과 삭제가 한 곳에서만 이루어진다.', '삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.']","[0, 1]","['삭제, POP', '시간복잡도', '삽입, PUSH', 'LIFO']","[0, 2, 3]",mjw8523@gmail.com
405,405,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"화장실에서 줄서서 기다리고 처리하는 형태의 자료구조로 한 방향에서는 삽입연산이, 반대편에서는 삭제연산이 이루어지는 자료구조이다. 스택과 마찬가지로 선형 자료구조이다. 한쪽 방향에서 삽입이, 반대편에서 삭제가 이루어지기 때문에 먼저 삽입된 데이터가 먼저 삭제되는 선입선출(FIFO) 구조를 가진다. 너비 우선 탐색(BFS) 구현에  사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
406,406,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,FIFO 자료구조. 자료를 추가 할 때는 PUSH 연산으로 QUEUE의 맨뒤의 자료를 추가한다. 자료를 제거 할 때는 POP 연산으로 QUEUE의 맨앞의 자료를 제거한다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
407,407,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"선입선출(First In First Out, FIFO)의 형태를 가지고 있는 자료구조이다.
먼저 온 것이 먼저 나가는 특성을 가지는 것이, 줄을 서서 기다릴 때 먼저 온 사람이 먼저 들어가는 것과 같은 이치이다. ","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
408,408,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 형식. 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다. 대표적으로 너비 우선 탐색(BFS) 구현에 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
409,409,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"정해진 곳(top)에서만 자료의 삽입과 삭제가 이루어지는 스택과는 다르게 큐는 Rear부분에서 자료의 삽입이, Front부분에서 자료의 삭제가 이루어집니다. 큐는 선입선출(FIFO, First In First Out)의 자료구조를 가집니다. 활용 예시로는 너비 우선 탐색 (BFS) 알고리즘이 있습니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
410,410,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue)는 한쪽 끝에서만 삽입이 이루어지고, 다른 한쪽 끝에서는 삭제 연산만 이루어지는 유한 순서 리스트이다. First in First Out (FIFO) 선입선출이라고 생각하면 쉽습니다. 먼저들어온것이 먼저 나가는 형식입니다. 즉, 제일 처음에 들어온 데이터가 먼저 삭제가 된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
411,411,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"가장 먼저 보관한 자료를 먼저 꺼내는 FIFO(First In First Out) 방식의 자료구조.
한쪽으로 보관하고 다른 쪽에서 꺼냄. 대기 순서에 따라 처리하는 연산에 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
412,412,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(queue)는 차례를 기다리는 줄이라는 의미를 가지고 있는 단어처럼 먼저 들어온 자료부터 순서대로 처리하는 방식을 말한다. 한 쪽 끝에서는 자료의 삽입 연산만 가능하고 반대쪽 끝에서는 삭제만 가능한 구조로서 선입선출(FIFO : First In First Out)의 특징을 가진다. 앞(front)에서는 삭제만 일어나고, 뒤(rear)에서는 삽입만 일어난다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
413,413,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"자료의 입력과 출력을 한 쪽 끝(front, rear)으로 제한한 자료구조.FIFO(First In First Out)구조 put(), get()컴퓨터 버퍼에서 주로 사용, 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기 시킨다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
414,414,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"한쪽 끝에서 삽입되고, 다른 한쪽 끝으로 삭제되는 리스트 구조의 일종임. 데이터의 입력,출력이 정해진 위치에서 만 가능. FIFO 규칙을 따른다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
415,415,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"번호표 순서대로 먼저 온 고객부터 처리해 주는 것과 같이 선입선출 형태의 구조를 큐(Queue)라고 부릅니다. 큐는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 자료구조이지만 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어지는 자료구조입니다. 데이터가 삽입된 순서대로 삭제되는 선입선출(FIFO, First-In-First-Out)  구조입니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
416,416,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue) 는 ""줄을 서서 기다린다.""라는 사전적 의미를 가지고 있다.
따라서, 큐 (Queue) 자료구조는, 먼저 들어온게 먼저 나가는 선입선출(FIFO, First In FirstOut) 방식의 자료구조이다. 큐는 주로, 데이터가 입력된 순서에 따라 처리되어야 할 때 사용되며 BFS 구현에 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
417,417,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,큐(Queue)는 스택(Stack)과 반대로 '선입선출 FIFO(First In First Out)' 의 구조를 가지고 있습니다. 말 그대로 먼저 들어온 것이 먼저 나가는 구조이기 때문에 데이터를 추가한 순서대로 제거할 수 있기 떄문에 스트리밍 등 소프트웨어 개발에서 응용되고 있습니다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
418,418,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue)는 FIFO(First In First Out) 의 특징을 갖는 자료구조이다. 입력 데이터들의 순서를 정하는데 최적화 되어있다.
가장 기본적으로 FIFO를 지원하지만, 특정 상태에 따라 우선순위를 결정하기도 한다. (= 우선순위 큐)","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
419,419,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐는 선입선출(First-in First-out)의 구조를 가지고 있습니다. 앞자를 따서 FIFO 구조라고 하며, 먼저 들어온 것이 먼저 나간다라는 뜻입니다. 공연장에서 입장을 기다리는 관객들을 예시로 들 수 있습니다. 큐는 입력된 순서대로 작업을 수행해야 할 때 활용할 수 있습니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
420,420,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"선입선출(First In First Out; FIFO)의 자료구조. 대기열이라고도 한다.  Queue라는 단어 자체가 표 같은 것을 구매하기 위해 줄서는 것을 의미한다.
데이터가 들어오는 위치는 가장 뒤(Rear 또는 Back이라고 한다.)에 있고, 데이터가 나가는 위치는 가장 앞(Front라고 한다.)에 있어서, 먼저 들어오는 데이터가 먼저 나가게 된다. ","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
421,421,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue) 는 사전적으로 ‘줄서서 기다리다’ , ‘대기행렬’ 이라는 의미를 가지고 있습니다. 큐(Queue) 자료구조는 줄에 기다리는 순서대로 먼저 줄을 선 사람이 먼저 입장하는 구조와 동일하게 이루어져있습니다. 이러한 특징을 선입선출(First-In First-Out) 이라고 표현합니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
422,422,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"1. 먼저 들어간 데이터가 먼저 나오는 선입선출, FIFO(First In First Out) 구조로, 줄을 서서 기다리는 구조와 같다.
2. 한 쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행한다.
3. 한 쪽 끝은 리어(rear)로 정하여 삽입 연산만 수행한다.
4. 그래프(Graph)의 넓이 우선 탐색(BFS)에 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
423,423,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,Queue는 대표적인 FIFO 구조이다.즉 FIFO그대로 먼저 넣은데이터가 먼저 빠지는것으로 이해할 수 있다. 즉 데이터를 한쪽으로 넣고 반대쪽으로 데이터가 빠지는 구조로 볼 수 있다. 보통 그래프의 넓이 우선 탐색 ( BFS ) 구현에 사용된다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
424,424,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐 (Queue)는 가장 먼저 삽입된 원소가 가장 먼저 삭제되는 선입선출 (FIFO, First-In First-Out)의 구조이다. 여러 원소들이 한 방향, 한 줄로 늘어선 형태라고 볼 수 있다. 큐에서의 삽입은 큐의 후단에서만 일어나며, 삭제는 큐의 전에서 일어난다. 원소 삽입과 삭제가 같은 쪽에서 일어나는 스택과 달리, 큐는 다른 쪽에서 일어난다","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
425,425,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"한 쪽으로만 들어가기 때문에 처음 들어간 것은 밑에 깔려서 나중에 나올 수 밖에 없다. (First In Last Out=FILO)

이로인해 삽입, 삭제, 조회시 O(1)의 시간복잡도가 소요된다.
","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[1, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
426,426,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(queue)는 컴퓨터 과학 분야에서 쓰이는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 형식을 말한다. 삽입과 삭제가 rear, front에서 각각 일어난다는 특징이 있으며, BFS에서 자주 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
427,427,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(queue)는 컴퓨터 과학 분야에서 쓰이는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 형식을 말한다. 삽입과 삭제가 rear, front에서 각각 일어난다는 특징이 있으며, DFS에서 자주 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
428,428,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"데이터를 관리하는 대표적인 방법으로, LIFO라는 특수한 순서를 따르는 리스트이다.  마지막으로 추가된 데이터가 제일 먼저 삭제된다. ","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[2, 3]",mjw8523@gmail.com
429,429,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue)는 한쪽 끝에서만 삽입이 이루어지고, 다른 한쪽 끝에서는 삭제 연산만 이루어지는 유한 순서 리스트이다. First in First Out (FIFO) 선입선출이라고 생각하면 쉽습니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
430,430,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"양쪽 끝에서만 데이터를 넣거나 뺼 수 있는 FIFO ( First In First Out ) 의 특징을 갖는 선형 자료구조이다. 삽입, 삭제는 O(1), 조회는 O(N)의 시간 복잡도를 가진다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[1, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
431,431,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(queue)는 차례를 기다리는 줄이라는 의미를 가지고 있는 단어처럼 먼저 들어온 자료부터 순서대로 처리하는 방식을 말한다.

한 쪽 끝에서는 자료의 삽입 연산만 가능하고 반대쪽 끝에서는 삭제만 가능한 구조로서 선입선출(FIFO : First In First Out)의 특징을 가진다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
432,432,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(queue)는 컴퓨터 과학 분야에서 쓰이는 컴퓨터의 기본적인 자료 구조의 한가지로, LIFO(Last In First Out)구조로 저장하는 형식을 말한다. 삽입과 삭제가 rear, front에서 각각 일어난다는 특징이 있으며, BFS에서 자주 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[2, 3]",mjw8523@gmail.com
433,433,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과는 달리
큐는 한쪽 끝에서 삽입이, 다른 쪽 끝에서 삭제가 양쪽으로 이루어진다.
이때 삭제연산이 수행되는 곳을 프론트(front), 삽입연산이 이루어지는 곳을 리어(rear)로 정하여
각각의 연산 작업만 수행된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[2, 3]",mjw8523@gmail.com
434,434,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐는 스택과 반대로 FIFO(First In First Out)의 구조를 가지고 있습니다. 먼저 들어오는 것이 먼저 나가는 구조이기 때문에 데이터를 추가한 순서대로 제거할 수 있으며, 이러한 특징 때문에 BFS 등의 개발에 사용되고 있습니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
435,435,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"양쪽 끝에서만 데이터를 넣거나 뺼 수 있는 FIFO ( First In First Out ) 의 특징을 갖는 선형 자료구조이다. 삽입, 삭제, 조회의 시간복잡도가 모두 O(N)이라는 특징을 가지고 있다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
436,436,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,양쪽 끝에서만 데이터를 넣거나 뺼 수 있는 FIFO ( First In First Out ) 의 특징을 갖는 선형 자료구조이다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
437,437,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired, Last In First Out(LIFO) 구조로 가장 나중에 들어간 원소가 가장 먼저 나오게 된다. ,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[],mjw8523@gmail.com
438,438,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐는 데이터가 삽입되고 삭제되는 곳이 달라, 먼저 들어온 데이터가 먼저나가는 FIFO의 특징을 갖고 있다. 보통 BFS와 같은 알고리즘에서 사용된다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
439,439,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"한쪽 끝에서 삽입되고, 다른 한쪽 끝으로 삭제되는 리스트 구조의 일종임

데이터의 입력,출력이 정해진 위치에서 만 가능. 자료 추가(삽입,입력)는 끝(rear)에서 만 가능

보통 BFS에서 많이 쓰임","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[0],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[2, 3]",mjw8523@gmail.com
440,440,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,큐(Queue)란 양 쪽 끝에서만 데이터를 넣거나 뺄 수 있는 선입선출(First-In-First-Out) 형태의 선형 자료구조이다. 입력된 순서대로 처리해야하는 너비 우선 탐색 등에 사용된다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
441,441,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐는 선입선출(First-in First-out)의 구조를 가지고 있습니다.

역시 앞자를 따서 FIFO 구조라고 하며, 먼저 들어온 것이 먼저 나간다라는 뜻입니다.

rear로만 삽입이 가능하고, front로만 삭제가 가능합니다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
442,442,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,큐(Queue)란 양 쪽 끝에서만 데이터를 넣거나 뺄 수 있는 선입선출(First-In-First-Out) 형태의 선형 자료구조이다. 입력된 순서대로 처리해야하는 BFS에 사용된다.,"['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']",[2],"['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']",[1],mjw8523@gmail.com
443,443,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue)란 양 쪽 끝에서만 데이터를 넣거나 뺄 수 있는 선입선출(First-In-First-Out) 형태의 선형 자료구조이다. 삽입과 삭제는 O(1)이, 조회는 O(N)이 걸린다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[1, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
444,444,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"데이터가 삽입된 순서대로 삭제되는 선입선출(FIFO, First-In-First-Out)  구조입니다.
한쪽 끝을 front로 정하여 삭제 연산만 수행하도록 하고 다른 쪽 끝은 rear로 정하여 삽입 연산만 수행하도록 제한하여 만든 자료구조입니다.
삽입 삭제는 O(1)에 가능하며, BFS에서 사용됩니다.

","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 1, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
445,445,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"데이터가 삽입된 순서대로 삭제되는 선입선출(FIFO, First-In-First-Out)  구조입니다.
한쪽 끝을 front로 정하여 삭제 연산만 수행하도록 하고 다른 쪽 끝은 rear로 정하여 삽입 연산만 수행하도록 제한하여 만든 자료구조입니다.
삽입 삭제는 O(1)에 가능하며, DFS에서 사용됩니다.

","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 1, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[0, 1, 2, 3]",mjw8523@gmail.com
446,446,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"선입선출(FIFO, First in first out) 방식의 자료구조를 말한다.  큐는 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어진다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
447,447,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐는 스택 자료구조와 달리 FIFO (First-In First-Out)- 선입 선출 특징으로
넣을 때에는 rear에서 밀어 넣어야 한다. 꺼낼 때에는 반대 쪽 ( front)에서 뽑아 꺼내야하는 제약이 있다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
448,448,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"큐(Queue)는 FIFO(First In First Out) 의 특징을 갖는 자료구조이다. 데이터를 추가(enqueue) 하는 곳을 리어(rear), 해제(dequeue) 하는 곳은 프런트(front)라 한다.

","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
449,449,4,[자료구조 3] Queue의 특징을 설명해주세요.,kshired,"선입선출(FIFO, First in first out) 방식의 자료구조를 말한다.  큐는 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어지며, BFS에서 사용된다는 특징이 있다.","['rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐', '삽입, 삭제의 시간 복잡도 O(1)', '먼저 삽입된 데이터가 먼저 나온다.']","[0, 2]","['시간복잡도', 'FIFO', '삭제, POP', '삽입, PUSH']","[1, 2, 3]",mjw8523@gmail.com
