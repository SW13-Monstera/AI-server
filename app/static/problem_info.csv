is_gradable,standard_answer,problem_id,score,grading_standard_id,created_at,updated_at,content,score,type,problem_id
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,741,2022-09-28 06:57:11.026982,2022-09-28 06:57:11.026982,저장위치,2,KEYWORD,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,742,2022-09-28 06:57:11.028075,2022-09-28 06:57:11.028075,보안,1,KEYWORD,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,743,2022-09-28 06:57:11.029956,2022-09-28 06:57:11.029956,라이프사이클,1,KEYWORD,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,744,2022-09-28 06:57:11.030618,2022-09-28 06:57:11.030618,속도,1,KEYWORD,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,745,2022-09-28 06:57:11.031278,2022-09-28 06:57:11.031278,"쿠키는 클라이언트측에 저장되고, 세션은 서버에 저장이 된다.",2,PROMPT,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,746,2022-09-28 06:57:11.031998,2022-09-28 06:57:11.031998,세션이 쿠키보다 보안에 유리하다.,1,PROMPT,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,747,2022-09-28 06:57:11.032670,2022-09-28 06:57:11.032670,세션이 쿠키보다 속도가 느리다.,1,PROMPT,443
,"먼저 **저장위치**에 차이가 있습니다. 쿠키는 클라이언트측에 저장되고 세션은 서버측에 저장이 됩니다. 세션은 서버를 거쳐야 하기 때문에 세션이 쿠키보다 **속도**가 느린 대신 **보안**에 유리합니다.

그리고 **라이프사이클**에 차이가 있는데 둘 다 만료기간을 정해놓지만 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제됩니다.",443,10,748,2022-09-28 06:57:11.034126,2022-09-28 06:57:11.034126,세션은 브라우저가 종료되면 만료기간이 남아있어도 삭제된다.,1,PROMPT,443
,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
대표적으로 GET은 멱등성을 가지며, POST는 멱등성을 가지지 않습니다.",446,10,920,2022-10-01 14:30:29.806083,2022-10-01 14:30:29.806083,상태,2,KEYWORD,446
,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
대표적으로 GET은 멱등성을 가지며, POST는 멱등성을 가지지 않습니다.",446,10,921,2022-10-01 14:30:29.843210,2022-10-01 14:30:29.843210,동일한 요청,1,KEYWORD,446
,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
대표적으로 GET은 멱등성을 가지며, POST는 멱등성을 가지지 않습니다.",446,10,922,2022-10-01 14:30:29.845704,2022-10-01 14:30:29.845704,서버가 상태가 요청후에도 동일하다.,2,PROMPT,446
,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
대표적으로 GET은 멱등성을 가지며, POST는 멱등성을 가지지 않습니다.",446,10,923,2022-10-01 14:30:29.846776,2022-10-01 14:30:29.846776,동일한 요청을 여러번 해도 결과가 바뀌지 않는다.,1,PROMPT,446
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,799,2022-09-30 03:30:28.640616,2022-09-30 03:30:28.640616,상호 배제,1.25,KEYWORD,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,800,2022-09-30 03:30:28.646883,2022-09-30 03:30:28.646883,점유 대기,1.25,KEYWORD,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,801,2022-09-30 03:30:28.647927,2022-09-30 03:30:28.647927,비선점,1.25,KEYWORD,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,802,2022-09-30 03:30:28.649170,2022-09-30 03:30:28.649170,순환 대기,1.25,KEYWORD,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,803,2022-09-30 03:30:28.650188,2022-09-30 03:30:28.650188,한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. ,1.25,PROMPT,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,804,2022-09-30 03:30:28.651233,2022-09-30 03:30:28.651233,"자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.",1.25,PROMPT,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,805,2022-09-30 03:30:28.652365,2022-09-30 03:30:28.652365,이미 할당된 자원을 강제로 빼앗을 수 없다.,1.25,PROMPT,447
,"상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.

순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.",447,10,806,2022-09-30 03:30:28.653389,2022-09-30 03:30:28.653389,대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.,1.25,PROMPT,447
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,783,2022-09-29 05:45:47.509008,2022-09-29 05:45:47.509008,영역 공유,1,KEYWORD,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,784,2022-09-29 05:45:47.510294,2022-09-29 05:45:47.510294,메모리,1,KEYWORD,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,785,2022-09-29 05:45:47.511220,2022-09-29 05:45:47.511220,작업 단위,1,KEYWORD,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,786,2022-09-29 05:45:47.512167,2022-09-29 05:45:47.512167,stack,1,KEYWORD,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,787,2022-09-29 05:45:47.513021,2022-09-29 05:45:47.513021,context switching,1,KEYWORD,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,788,2022-09-29 05:45:47.513880,2022-09-29 05:45:47.513880,프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.,1,PROMPT,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,789,2022-09-29 05:45:47.514707,2022-09-29 05:45:47.514707,스레드는 할당받은 자원을 이용하는 실행의 단위이다.,1,PROMPT,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,790,2022-09-29 05:45:47.515538,2022-09-29 05:45:47.515538,스레드는 프로세스 내에 존재한다.,1,PROMPT,448
,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위지만, 스레드는 할당받은 자원을 이용하는 실행의 단위입니다. 다른말로 프로세스는 프로그램, 스레드는 Task 단위라고도 합니다. 메모리의 관점에서 스레드는 프로세스의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재해요.. 또 프로세스에 비해 스레드는 공유하는 영역이 있기 때문에 Context Switching이 빠릅니다.",448,10,791,2022-09-29 05:45:47.516578,2022-09-29 05:45:47.516578,스레드는 프로세스의 Stack영역을 제외한 모든 영역을 공유한다.,2,PROMPT,448
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,792,2022-09-29 06:01:53.651008,2022-09-29 06:01:53.651008,FIFO,2,KEYWORD,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,793,2022-09-29 06:01:53.652201,2022-09-29 06:01:53.652201,"삽입, PUSH",1,KEYWORD,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,794,2022-09-29 06:01:53.653042,2022-09-29 06:01:53.653042,"삭제, POP",1,KEYWORD,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,795,2022-09-29 06:01:53.653806,2022-09-29 06:01:53.653806,시간복잡도,1,KEYWORD,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,796,2022-09-29 06:01:53.655298,2022-09-29 06:01:53.655298,먼저 삽입된 데이터가 먼저 나온다.,2,PROMPT,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,797,2022-09-29 06:01:53.656192,2022-09-29 06:01:53.656192,rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐,1,PROMPT,449
,"먼저 입력된게 가장 먼저 나오는 FIFO 방식의 자료구조이며 Rear에서 자료의 삽입이, Front에서 자료의 삭제가 이루어집니다. 삽입과 삭제의 시간 복잡도는 O(1)을 가지며 조회의 시간복잡도는 O(N)을 가집니다.",449,10,798,2022-09-29 06:01:53.657664,2022-09-29 06:01:53.657664,"삽입, 삭제의 시간 복잡도 O(1)",2,PROMPT,449
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,807,2022-09-30 04:15:38.177329,2022-09-30 04:15:38.177329,후보키,1,KEYWORD,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,808,2022-09-30 04:15:38.178581,2022-09-30 04:15:38.178581,"유일성, unique",1,KEYWORD,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,809,2022-09-30 04:15:38.179554,2022-09-30 04:15:38.179554,NULL,1,KEYWORD,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,810,2022-09-30 04:15:38.180465,2022-09-30 04:15:38.180465,대표성,1,KEYWORD,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,811,2022-09-30 04:15:38.181435,2022-09-30 04:15:38.181435,후보키 중 엔티티를 대표할 수 있는 키이다.,1,PROMPT,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,812,2022-09-30 04:15:38.182406,2022-09-30 04:15:38.182406,특정 튜플을 유일하게 구별할 수 있는 속성을 가진다.,1,PROMPT,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,813,2022-09-30 04:15:38.183294,2022-09-30 04:15:38.183294,키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.,1,PROMPT,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,814,2022-09-30 04:15:38.184390,2022-09-30 04:15:38.184390,NULL 값을 가질 수 없다.,1,PROMPT,450
,"후보키중 엔티티를 대표할 수 있는 키로써 각 행을 유일하게 구별할 수 있는 속성을 가지고 있습니다.
키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성해야 하고 NULL 값을 가질 수 없습니다.
또한 한 번 부여된 key 값은 변하지 않아야 합니다.",450,10,815,2022-09-30 04:15:38.186149,2022-09-30 04:15:38.186149,자주 변경되지 않아야 한다.,1,PROMPT,450
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,816,2022-09-30 04:19:04.196254,2022-09-30 04:19:04.196254,일관성,1.25,KEYWORD,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,817,2022-09-30 04:19:04.197478,2022-09-30 04:19:04.197478,원자성,1.25,KEYWORD,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,818,2022-09-30 04:19:04.203427,2022-09-30 04:19:04.203427,독립성,1.25,KEYWORD,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,819,2022-09-30 04:19:04.204652,2022-09-30 04:19:04.204652,지속성,1.25,KEYWORD,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,820,2022-09-30 04:19:04.205631,2022-09-30 04:19:04.205631,트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.,1.25,PROMPT,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,821,2022-09-30 04:19:04.206710,2022-09-30 04:19:04.206710,만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.,1.25,PROMPT,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,822,2022-09-30 04:19:04.207676,2022-09-30 04:19:04.207676,각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.,1.25,PROMPT,451
,"일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

독립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성 : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.",451,10,823,2022-09-30 04:19:04.209187,2022-09-30 04:19:04.209187,트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.,1.25,PROMPT,451
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,824,2022-09-30 04:23:48.257283,2022-09-30 04:23:48.257283,LIFO,2,KEYWORD,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,825,2022-09-30 04:23:48.258734,2022-09-30 04:23:48.258734,"삽입, PUSH",1,KEYWORD,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,826,2022-09-30 04:23:48.259758,2022-09-30 04:23:48.259758,"삭제, POP",1,KEYWORD,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,827,2022-09-30 04:23:48.260831,2022-09-30 04:23:48.260831,시간복잡도,1,KEYWORD,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,828,2022-09-30 04:23:48.261836,2022-09-30 04:23:48.261836,마지막으로 들어온 데이터가 처음으로 나간다.,2,PROMPT,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,829,2022-09-30 04:23:48.262639,2022-09-30 04:23:48.262639,자료의 삽입과 삭제가 한 곳에서만 이루어진다.,1,PROMPT,452
,"Stack 자료구조는 마지막으로 들어온 데이터가 처음으로 나간다는 LIFO 형태를 가지고 자료의 삽입, 삭제가 한 곳에서만 이루어집니다. 보통 Array로 구현을 하기 때문에 삽입, 삭제, 조회는 O(1)의 시간복잡도를 가집니다.",452,10,830,2022-09-30 04:23:48.266173,2022-09-30 04:23:48.266173,"삽입, 삭제, 조회의 시간복잡도가 O(1)이 걸린다.",2,PROMPT,452
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,831,2022-09-30 05:31:07.293683,2022-09-30 05:31:07.293683,카디널리티,1.25,KEYWORD,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,832,2022-09-30 05:31:07.294842,2022-09-30 05:31:07.294842,선택도,1.25,KEYWORD,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,833,2022-09-30 05:31:07.296236,2022-09-30 05:31:07.296236,수정 빈도,1.25,KEYWORD,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,834,2022-09-30 05:31:07.297454,2022-09-30 05:31:07.297454,조회 빈도,1.25,KEYWORD,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,835,2022-09-30 05:31:07.298330,2022-09-30 05:31:07.298330,카디널리티가 상대적으로 높은 컬럼,1.25,PROMPT,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,836,2022-09-30 05:31:07.299469,2022-09-30 05:31:07.299469,선택도가 상대적으로 낮은 컬럼,1.25,PROMPT,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,837,2022-09-30 05:31:07.300372,2022-09-30 05:31:07.300372,수정 빈도가 낮은 컬럼,1,PROMPT,453
,"index는 중복도와 높은 관련이 있지만 중복도는 카디널리티와 선택도에 관련이 있습니다.
중복도가 높다는건 카디널리티가 상대적으로 높고 선택도가 상대적으로 낮다는걸 뜻합니다.
(선택도와 카디널리티는 굉장히 헷갈릴 수 있는 개념이라 한 번쯤 이해하고 넘어가는게 좋습니다.)
또한 수정 빈도가 낮고 조건절에서 많이 사용되어 조회 빈도가 높은 컬럼에 적합합니다.",453,10,838,2022-09-30 05:31:07.301316,2022-09-30 05:31:07.301316,조회 빈도가 높은 컬럼,1.25,PROMPT,453
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,845,2022-09-30 05:47:33.621127,2022-09-30 05:47:33.621127,저장 순서,2,KEYWORD,454
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,846,2022-09-30 05:47:33.622392,2022-09-30 05:47:33.622392,시간 복잡도,1,KEYWORD,454
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,847,2022-09-30 05:47:33.623333,2022-09-30 05:47:33.623333,랜덤 엑세스,2,KEYWORD,454
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,848,2022-09-30 05:47:33.624228,2022-09-30 05:47:33.624228,논리적 저장 순서와 물리적 저장 순서가 일치한다.,2,PROMPT,454
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,849,2022-09-30 05:47:33.625080,2022-09-30 05:47:33.625080,인덱스(index)로 해당 원소(element)에 접근할 수 있다.,2,PROMPT,454
,"Array는 논리적 저장 순서와 물리적 저장 순서가 일치하며 인덱스를 통해 원하는 원소에 접근할 수 있습니다.
원소에 접근할때는 O(1)의 시간복잡도로 랜덤 엑세스가 가능합니다.",454,10,850,2022-09-30 05:47:33.625900,2022-09-30 05:47:33.625900,O(1)의 시간복잡도로 랜덤 액세스가 가능하다.,1,PROMPT,454
